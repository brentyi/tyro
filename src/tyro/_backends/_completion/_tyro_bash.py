"""Bash completion generation for tyro using embedded Python logic."""

from __future__ import annotations

from ... import _parsers
from ._base import CompletionGenerator
from ._python_completer import get_embedded_code
from ._spec import build_completion_spec


class TyroBashCompletionGenerator(CompletionGenerator):
    """Generates bash completion scripts with embedded Python logic."""

    def generate(
        self,
        parser_spec: _parsers.ParserSpecification,
        prog: str,
        root_prefix: str,
    ) -> str:
        """Generate a bash completion script.

        Args:
            parser_spec: Parser specification to generate completion for.
            prog: Program name.
            root_prefix: Prefix for completion function names.

        Returns:
            Bash completion script as a string.
        """
        # Build completion spec.
        spec = build_completion_spec(parser_spec, prog)
        spec_repr = repr(spec)

        # Get embedded Python code.
        python_code = get_embedded_code()

        # Generate the bash completion script.
        script = f"""# AUTOMATICALLY GENERATED by tyro
# Bash completion for {prog}

# Main completion function.
_{root_prefix}() {{
  local cur="${{COMP_WORDS[COMP_CWORD]}}"
  local prev="${{COMP_WORDS[COMP_CWORD-1]}}"

  # Get completions from Python.
  local python_cmd
  if command -v python3 >/dev/null 2>&1; then
    python_cmd="python3"
  elif command -v python >/dev/null 2>&1; then
    python_cmd="python"
  else
    COMPREPLY=()
    return 1
  fi

  # Get completions (format: "completion:description").
  local completions
  completions=$("$python_cmd" - "${{COMP_WORDS[@]}}" "$COMP_CWORD" << 'PYTHON_EOF'
# Hardcoded completion spec.
COMPLETION_SPEC = {spec_repr}

{python_code}
PYTHON_EOF
)

  # Parse completions and extract just the completion part (before the tab).
  local IFS=$'\\n'
  local -a completion_list
  while IFS= read -r line; do
    # Extract the part before the first tab.
    local completion="${{line%%$'\\t'*}}"
    # Escape colons to prevent them from being treated as word separators.
    completion="${{completion//:/\\\\:}}"
    completion_list+=("$completion")
  done <<< "$completions"

  # Filter completions based on current word.
  # Also escape colons in the current word for matching.
  local cur_escaped="${{cur//:/\\\\:}}"
  COMPREPLY=( $(compgen -W "${{completion_list[*]}}" -- "$cur_escaped") )

  # Unescape colons in the final completions.
  local i
  for i in "${{!COMPREPLY[@]}}"; do
    COMPREPLY[$i]="${{COMPREPLY[$i]//\\\\:/:}}"
  done

  return 0
}}

complete -F _{root_prefix} {prog}
"""
        return script
