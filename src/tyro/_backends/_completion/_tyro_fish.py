"""Fish completion generation for tyro using embedded Python logic."""

from __future__ import annotations

from ... import _parsers
from ._base import CompletionGenerator
from ._python_completer import get_embedded_code
from ._spec import build_completion_spec


class TyroFishCompletionGenerator(CompletionGenerator):
    """Generates Fish completion scripts with embedded Python logic."""

    def generate(
        self,
        parser_spec: _parsers.ParserSpecification,
        prog: str,
        root_prefix: str,
    ) -> str:
        """Generate a Fish completion script.

        Args:
            parser_spec: Parser specification to generate completion for.
            prog: Program name.
            root_prefix: Prefix for completion function names.

        Returns:
            Fish completion script as a string.
        """
        # Build completion spec.
        spec = build_completion_spec(parser_spec, prog)
        spec_repr = repr(spec)

        # Get embedded Python code.
        python_code = get_embedded_code().replace('"', r"\"")

        # Generate the fish completion script.
        script = f"""# AUTOMATICALLY GENERATED by tyro

# Main completion function.

function _{root_prefix}
    if command -sq python3
        set python_cmd python3
    else if command -sq python
        set python_cmd python
    else
        return
    end

    set -l words (commandline -xpc)
    set -l current (count $words)
    set -l pycode "
# Hardcoded completion spec.
COMPLETION_SPEC = {spec_repr}
{python_code}
"
    $python_cmd -c "$pycode" $words $current
end

# Register completion for the full program name.
complete --no-files --command {prog} --arguments "(_{root_prefix})"

# Also register for basename to handle ./script invocations.
set _prog_basename (basename {prog})

complete --no-files --command $_prog_basename --arguments "(_{root_prefix})"
complete --no-files --command "./$_prog_basename" --arguments "(_{root_prefix})"

"""
        return script
