import contextlib
import dataclasses
import io
import pathlib
import re
import shutil
import subprocess
import sys
import tempfile
from typing import List, Union

import pytest
from typing_extensions import Annotated, Literal, Optional

import tyro


# https://github.com/brentyi/tyro/issues/9
@dataclasses.dataclass(frozen=True)
class Subtype:
    data: int = 1


@dataclasses.dataclass(frozen=True)
class TypeA:
    subtype: Subtype = Subtype(1)


@dataclasses.dataclass(frozen=True)
class TypeB:
    subtype: Subtype = Subtype(2)


@dataclasses.dataclass(frozen=True)
class Wrapper:
    supertype: Union[TypeA, TypeB] = TypeA()


def test_bash(backend: str):
    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(Wrapper, args=["--tyro-print-completion", "bash"])

    output = target.getvalue()
    # Check for appropriate signature based on backend.
    if backend == "argparse":
        assert "# AUTOMATICALLY GENERATED by `shtab`" in output
    else:  # tyro backend.
        assert "# AUTOMATICALLY GENERATED by tyro" in output


def test_zsh(backend: str):
    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(Wrapper, args=["--tyro-print-completion", "zsh"])

    output = target.getvalue()
    # Check for appropriate signature based on backend.
    if backend == "argparse":
        assert "# AUTOMATICALLY GENERATED by `shtab`" in output
    else:  # tyro backend.
        assert "# AUTOMATICALLY GENERATED by tyro" in output
        # Check that zsh-specific syntax is present.
        assert "#compdef" in output
        # New tyro backend uses embedded Python, not _arguments.
        assert "PYTHON_EOF" in output or "_arguments" in output


def test_completion_zsh(backend: str):
    """https://github.com/brentyi/tyro/issues/158"""

    def start_device(
        preset: Annotated[
            Optional[Literal["rgb", "depth", "ir"]], tyro.conf.arg(aliases=["-p"])
        ] = None,
        frame: Annotated[
            Literal["world", "base"], tyro.conf.arg(aliases=["-f"])
        ] = "world",
    ) -> None:
        """
        Start device with the given preset.

        :param preset: device preset to use.
        :param frame: coordinate frame to use.
        """

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(start_device, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()
    print(completion_script)

    # Check for appropriate signature based on backend.
    if backend == "argparse":
        assert "# AUTOMATICALLY GENERATED by `shtab`" in completion_script
    else:  # tyro backend.
        assert "# AUTOMATICALLY GENERATED by tyro" in completion_script

    # Both backends should have choices.
    if backend == "argparse":
        assert "preset_choices=(" in completion_script
        assert "p_choices=(" in completion_script
        assert "frame_choices=(" in completion_script
        assert "f_choices=(" in completion_script
    else:  # tyro backend uses Python spec.
        # Check that choices are in the embedded Python spec.
        assert "'choices':" in completion_script
        assert "rgb" in completion_script
        assert "depth" in completion_script
        assert "world" in completion_script
        assert "base" in completion_script


def _strip_comments_and_normalize(script: str) -> str:
    """Strip comments and normalize whitespace for comparison.

    This removes:
    - Lines starting with # (comments)
    - Empty lines
    - Leading/trailing whitespace

    Then normalizes remaining whitespace for comparison.
    """
    lines = []
    for line in script.split("\n"):
        stripped = line.strip()
        # Skip empty lines and comment lines.
        if not stripped or stripped.startswith("#"):
            continue
        lines.append(stripped)
    return "\n".join(lines)


def test_completion_output_parity():
    """Test that argparse and tyro backends produce equivalent completion scripts.

    The scripts should be functionally identical (ignoring comments and formatting).
    """

    def simple_function(
        x: int = 5,
        y: Annotated[str, tyro.conf.arg(aliases=["-y"])] = "hello",
        flag: bool = False,
    ) -> None:
        """Simple function for testing completion parity."""

    # Generate completion with argparse backend.
    original_backend = tyro._experimental_options["backend"]
    tyro._experimental_options["backend"] = "argparse"

    target_argparse = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target_argparse):
        tyro.cli(simple_function, args=["--tyro-print-completion", "bash"])

    # Generate completion with tyro backend.
    tyro._experimental_options["backend"] = "tyro"

    target_tyro = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target_tyro):
        tyro.cli(simple_function, args=["--tyro-print-completion", "bash"])

    # Restore original backend.
    tyro._experimental_options["backend"] = original_backend

    # Strip comments and compare.
    argparse_normalized = _strip_comments_and_normalize(target_argparse.getvalue())
    tyro_normalized = _strip_comments_and_normalize(target_tyro.getvalue())

    # Different architectures but same functionality.
    # Argparse backend uses bash variables, tyro backend uses embedded Python.
    assert "_option_strings=" in argparse_normalized
    assert "COMPLETION_SPEC" in tyro_normalized
    assert "PYTHON_EOF" in tyro_normalized

    # Check that both have the same options (though in possibly different order/format).
    assert "--x" in argparse_normalized and "--x" in tyro_normalized
    assert "-y" in argparse_normalized and "-y" in tyro_normalized
    assert "--flag" in argparse_normalized and "--flag" in tyro_normalized
    assert "--no-flag" in argparse_normalized and "--no-flag" in tyro_normalized


def test_completion_parity_with_subcommands():
    """Test completion parity for simple subcommands (no CascadeSubcommandArgs)."""

    @dataclasses.dataclass
    class SubA:
        value_a: int = 1

    @dataclasses.dataclass
    class SubB:
        value_b: str = "hello"

    @dataclasses.dataclass
    class Config:
        sub: Union[SubA, SubB]

    # Generate completion with argparse backend.
    original_backend = tyro._experimental_options["backend"]
    tyro._experimental_options["backend"] = "argparse"

    target_argparse = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target_argparse):
        tyro.cli(Config, args=["--tyro-print-completion", "bash"])

    # Generate completion with tyro backend.
    tyro._experimental_options["backend"] = "tyro"

    target_tyro = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target_tyro):
        tyro.cli(Config, args=["--tyro-print-completion", "bash"])

    # Restore original backend.
    tyro._experimental_options["backend"] = original_backend

    argparse_output = target_argparse.getvalue()
    tyro_output = target_tyro.getvalue()

    # Both should have subcommands.
    assert "sub:sub-a" in argparse_output or "sub_a" in argparse_output
    assert "sub:sub-b" in argparse_output or "sub_b" in argparse_output
    assert "sub:sub-a" in tyro_output or "sub_a" in tyro_output
    assert "sub:sub-b" in tyro_output or "sub_b" in tyro_output

    # Both should have the subcommand arguments (possibly with prefix).
    assert (
        "--value-a" in argparse_output
        or "--value_a" in argparse_output
        or "--sub.value-a" in argparse_output
        or "--sub.value_a" in argparse_output
    )
    assert (
        "--value-b" in argparse_output
        or "--value_b" in argparse_output
        or "--sub.value-b" in argparse_output
        or "--sub.value_b" in argparse_output
    )
    assert (
        "--value-a" in tyro_output
        or "--value_a" in tyro_output
        or "--sub.value-a" in tyro_output
        or "--sub.value_a" in tyro_output
    )
    assert (
        "--value-b" in tyro_output
        or "--value_b" in tyro_output
        or "--sub.value-b" in tyro_output
        or "--sub.value_b" in tyro_output
    )


def test_path_completion(backend: str):
    """Test that path arguments get proper file/directory completion."""
    from pathlib import Path

    def path_function(
        input_file: Path,
        output_dir: Path,
        config_path: str,
    ) -> None:
        """Function with path arguments."""

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(path_function, args=["--tyro-print-completion", "bash"])

    output = target.getvalue()

    if backend == "tyro":
        # New Python-based backend: check for path types in the spec.
        assert "'type': 'path'" in output
        assert "'is_directory': True" in output or "'is_directory': False" in output
    else:
        # Argparse backend uses shtab helper functions.
        assert "_shtab_compgen_files" in output or "_shtab_compgen_dirs" in output


def test_cascaded_subcommand_completion(backend: str):
    """Test completion for cascaded subcommands.

    This tests the tyro-specific CascadeSubcommandArgs feature, which allows
    more flexible argument ordering. The completion should include all available
    options at each level.
    """

    @dataclasses.dataclass
    class SubA:
        sub_value: int = 1

    @dataclasses.dataclass
    class SubB:
        sub_value: int = 2

    @dataclasses.dataclass
    class Config:
        parent_arg: str = "default"
        sub: Union[SubA, SubB] = dataclasses.field(default_factory=SubA)

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(
            tyro.conf.CascadeSubcommandArgs[Config],
            args=["--tyro-print-completion", "bash"],
        )

    output = target.getvalue()

    # Both backends should generate completions with subcommands.
    assert "sub:sub-a" in output or "sub_a" in output
    assert "sub:sub-b" in output or "sub_b" in output
    # Parent argument should be available.
    assert "--parent-arg" in output or "--parent_arg" in output


def test_completion_uses_correct_prog_name(backend: str):
    """Test that completion scripts use the correct program name from sys.argv[0].

    The completion script should be registered for the actual script being run,
    not for a hardcoded 'tyro' command.
    """

    # Create a temporary script.
    with tempfile.NamedTemporaryFile(
        mode="w", suffix=".py", delete=False
    ) as script_file:
        script_file.write(
            """
import tyro

def main(x: int = 5):
    pass

if __name__ == "__main__":
    tyro.cli(main)
"""
        )
        script_path = script_file.name

    try:
        # Generate bash completion.
        result_bash = subprocess.run(
            [sys.executable, script_path, "--tyro-print-completion", "bash"],
            capture_output=True,
            text=True,
            check=False,
        )
        assert result_bash.returncode == 0
        bash_output = result_bash.stdout

        # Generate zsh completion.
        result_zsh = subprocess.run(
            [sys.executable, script_path, "--tyro-print-completion", "zsh"],
            capture_output=True,
            text=True,
            check=False,
        )
        assert result_zsh.returncode == 0
        zsh_output = result_zsh.stdout

        # Verify bash completion uses the script name.
        assert "complete -F" in bash_output
        assert script_path in bash_output
        if backend == "argparse":
            assert "complete -o filenames -F _tyro_tyro tyro" not in bash_output
        # For tyro backend, we just check that the script path is in the completion command.

        # Verify zsh completion uses the script name.
        assert f"#compdef {script_path}" in zsh_output
        assert "#compdef tyro" not in zsh_output

    finally:
        # Clean up.

        pathlib.Path(script_path).unlink(missing_ok=True)


class BashCompletionTester:
    """Helper class for testing bash completions functionally.

    Based on shtab's testing approach.
    """

    def __init__(self, completion_script: str):
        """Initialize with a completion script.

        Args:
            completion_script: The bash completion script to test.
        """
        self.completion_script = completion_script

    def get_completions(self, words: List[str], cword: int) -> List[str]:
        """Simulate bash completion for a command line.

        Args:
            words: List of words on the command line (e.g., ["prog", "sub1", ""]).
            cword: Index of the word being completed (0-based).

        Returns:
            List of completions from COMPREPLY.
        """
        # Extract the completion function name from the script.
        # It's registered with: complete -F <func_name> <prog>
        match = re.search(r"complete -F (\S+)", self.completion_script)
        if not match:
            raise ValueError("Could not find completion function in script")
        func_name = match.group(1)

        # Build bash array syntax for COMP_WORDS.
        words_escaped = " ".join(f'"{w}"' for w in words)

        test_script = f"""
{self.completion_script}

# Set up completion environment.
COMP_WORDS=({words_escaped})
COMP_CWORD={cword}

# Call the completion function.
{func_name}

# Output completions, one per line.
printf '%s\\n' "${{COMPREPLY[@]}}"
"""

        proc = subprocess.Popen(
            ["bash", "-c", test_script],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        stdout, stderr = proc.communicate()

        if proc.returncode != 0:
            raise RuntimeError(
                f"Bash completion failed:\n{stderr.decode() if stderr else ''}"
            )

        # Parse output - one completion per line.
        output = stdout.decode().strip()
        if not output:
            return []
        return output.split("\n")

    def test_compgen(
        self, compgen_cmd: str, word: str, expected_completions: str
    ) -> None:
        """Test that compgen produces expected completions.

        Args:
            compgen_cmd: The compgen command (e.g., '-W "foo bar"').
            word: The word to complete.
            expected_completions: Space-separated expected completions.
        """

        test_script = f'{self.completion_script}\n[[ "$(echo $(compgen {compgen_cmd} -- "{word}"))" = "{expected_completions}" ]]'

        proc = subprocess.Popen(
            ["bash", "-o", "pipefail", "-euc", test_script],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        stdout, stderr = proc.communicate()
        assert proc.returncode == 0, f"""compgen test failed:
compgen {compgen_cmd} -- "{word}"
Expected: {expected_completions}
=== stdout ===
{stdout.decode() if stdout else ""}
=== stderr ===
{stderr.decode() if stderr else ""}"""


def test_bash_functional_completion_simple(backend: str):
    """Test that bash completion actually works for a simple case."""
    if backend != "tyro":
        pytest.skip("Testing tyro-specific completion behavior")

    @dataclasses.dataclass
    class Config:
        mode: Literal["train", "eval", "test"] = "train"
        verbose: bool = False

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(Config, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()
    tester = BashCompletionTester(completion_script)

    # Test completions at root level.
    completions = tester.get_completions(["prog", ""], 1)
    # Should have exactly these completions (flags for mode, verbose, help).
    expected_root = {"-h", "--help", "--mode", "--verbose", "--no-verbose"}
    assert set(completions) == expected_root, (
        f"Root completions mismatch.\nExpected: {expected_root}\nGot: {set(completions)}"
    )

    # Test completing after --mode shows only the choices.
    completions = tester.get_completions(["prog", "--mode", ""], 2)
    expected_choices = {"train", "eval", "test"}
    assert set(completions) == expected_choices, (
        f"Mode choices mismatch.\nExpected: {expected_choices}\nGot: {set(completions)}"
    )

    # Test partial completion of mode values filters correctly.
    completions = tester.get_completions(["prog", "--mode", "tr"], 2)
    assert set(completions) == {"train"}, (
        f"Partial completion should only show 'train', got: {completions}"
    )


def test_bash_functional_completion_with_subcommands(backend: str):
    """Test bash completion with subcommands."""
    if backend != "tyro":
        pytest.skip("Testing tyro-specific completion behavior")

    @dataclasses.dataclass
    class DatasetMnist:
        binary: bool = False

    @dataclasses.dataclass
    class DatasetImageNet:
        subset: Literal[50, 100, 1000] = 50

    @dataclasses.dataclass
    class OptimizerConfig:
        dataset: Union[DatasetMnist, DatasetImageNet]

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(OptimizerConfig, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()
    tester = BashCompletionTester(completion_script)

    # Test root level shows only subcommands and help.
    completions = tester.get_completions(["prog", ""], 1)
    mnist_subcmd = next((c for c in completions if "mnist" in c.lower()), None)
    imagenet_subcmd = next((c for c in completions if "image" in c.lower()), None)
    assert mnist_subcmd is not None, f"mnist subcommand not found in {completions}"
    assert imagenet_subcmd is not None, (
        f"imagenet subcommand not found in {completions}"
    )

    # Root should only have help flags and subcommands - no other options.
    expected_root = {"-h", "--help", mnist_subcmd, imagenet_subcmd}
    assert set(completions) == expected_root, (
        f"Root completions mismatch.\nExpected: {expected_root}\nGot: {set(completions)}"
    )

    # Test that selecting mnist subcommand shows exactly its options.
    completions = tester.get_completions(["prog", mnist_subcmd, ""], 2)
    # Options have prefix like --dataset.binary.
    expected_mnist = {"-h", "--help", "--dataset.binary", "--dataset.no-binary"}
    assert set(completions) == expected_mnist, (
        f"Mnist completions mismatch.\nExpected: {expected_mnist}\nGot: {set(completions)}"
    )
    # Should not have imagenet's --subset option.
    assert not any("subset" in c for c in completions), (
        f"--subset should not appear in mnist context, got: {completions}"
    )

    # Test that selecting imagenet subcommand shows exactly its options.
    completions = tester.get_completions(["prog", imagenet_subcmd, ""], 2)
    expected_imagenet = {"-h", "--help", "--dataset.subset"}
    assert set(completions) == expected_imagenet, (
        f"ImageNet completions mismatch.\nExpected: {expected_imagenet}\nGot: {set(completions)}"
    )
    # Should not have mnist's --binary option.
    assert not any("binary" in c for c in completions), (
        f"--binary should not appear in imagenet context, got: {completions}"
    )


def test_bash_functional_completion_frontier_subcommands(backend: str):
    """Test bash completion with frontier (multiple Union) subcommands.

    Tests the scenario where subcommands can be selected from multiple Union fields.
    This is a key difference between backends:
    - tyro backend: Shows ALL frontier subcommands at once (flat)
    - argparse backend: Shows nested subcommands (sequential selection)
    """

    @dataclasses.dataclass
    class DatasetMnist:
        pass

    @dataclasses.dataclass
    class DatasetImageNet:
        pass

    @dataclasses.dataclass
    class OptimizerAdam:
        learning_rate: float = 1e-4

    @dataclasses.dataclass
    class OptimizerSgd:
        learning_rate: float = 1e-3

    @dataclasses.dataclass
    class Config:
        dataset: Union[DatasetMnist, DatasetImageNet]
        optimizer: Union[OptimizerAdam, OptimizerSgd]

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(Config, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()

    # Both backends should have all subcommands somewhere in the completion script.
    assert "mnist" in completion_script.lower()
    assert "image" in completion_script.lower()
    assert "adam" in completion_script.lower()
    assert "sgd" in completion_script.lower()

    # Check the key difference: frontier behavior.
    if backend == "tyro":
        # Tyro backend uses Python spec with frontier_groups.
        assert "'frontier_groups':" in completion_script
        # Should have 2 groups (datasets and optimizers).
        assert "[[" in completion_script  # Nested lists indicate frontier groups.

        # Verify all 4 subcommands are in the spec.
        assert (
            "'dataset" in completion_script.lower()
            or "mnist" in completion_script.lower()
        )
        assert (
            "'optimizer" in completion_script.lower()
            or "adam" in completion_script.lower()
        )
    else:  # argparse backend
        # Find the main subparsers array definition.
        main_subparsers_match = re.search(
            r"(_\w+)_subparsers=\(([^)]+)\)", completion_script
        )
        assert main_subparsers_match, "Could not find main subparsers array"

        main_subparsers_content = main_subparsers_match.group(2)

        # Argparse backend: Nested structure - only shows dataset subcommands initially.
        # Should have 2 subcommands in main array (just datasets).
        subcommand_count = len(
            re.findall(r"'[^']*(?:mnist|image|adam|sgd)[^']*'", main_subparsers_content)
        )
        assert subcommand_count == 2, (
            f"Argparse backend should show 2 dataset subcommands in main array, "
            f"found {subcommand_count}: {main_subparsers_content}"
        )
        # Optimizer subcommands should be in nested arrays.
        assert re.search(
            r"_dataset_[^_]+_subparsers=\([^)]*adam[^)]*\)", completion_script
        ), "Argparse backend should have nested optimizer subparsers"


def test_bash_functional_completion_cascade_subcommand_args(backend: str):
    """Test bash completion with CascadeSubcommandArgs marker.

    CascadeSubcommandArgs allows parent options to appear at the same level as subcommands,
    so users can specify them before selecting a subcommand.
    """
    if backend != "tyro":
        pytest.skip("Testing tyro-specific completion behavior")

    @dataclasses.dataclass
    class SubcommandA:
        arg_a: int = 1

    @dataclasses.dataclass
    class SubcommandB:
        arg_b: str = "hello"

    @dataclasses.dataclass
    class Config:
        """Config with CascadeSubcommandArgs."""

        common: Annotated[int, tyro.conf.arg(aliases=["-c"])] = 5
        subcommand: Union[SubcommandA, SubcommandB] = dataclasses.field(
            default_factory=SubcommandA
        )

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(
            tyro.conf.CascadeSubcommandArgs[Config],
            args=["--tyro-print-completion", "bash"],
        )

    completion_script = target.getvalue()
    tester = BashCompletionTester(completion_script)

    # Test 1: At root level, should see subcommands, help, AND parent options together.
    # This is the key cascade behavior - options appear alongside subcommands.
    completions = tester.get_completions(["prog", ""], 1)
    subcmd_a = next((c for c in completions if "subcommand-a" in c.lower()), None)
    subcmd_b = next((c for c in completions if "subcommand-b" in c.lower()), None)
    assert subcmd_a is not None, f"subcommand-a not found in {completions}"
    assert subcmd_b is not None, f"subcommand-b not found in {completions}"

    # Root should have help, subcommands, AND the common option (cascade behavior).
    expected_root = {"-h", "--help", subcmd_a, subcmd_b, "--common", "-c"}
    assert set(completions) == expected_root, (
        f"Root completions mismatch.\nExpected: {expected_root}\nGot: {set(completions)}"
    )

    # Test 2: After selecting subcommand-a, should see exactly its options.
    completions = tester.get_completions(["prog", subcmd_a, ""], 2)
    expected_subcmd_a = {"-h", "--help", "--subcommand.arg-a"}
    assert set(completions) == expected_subcmd_a, (
        f"SubcommandA completions mismatch.\nExpected: {expected_subcmd_a}\nGot: {set(completions)}"
    )
    # Should not have subcommand-b's option.
    assert not any("arg-b" in c for c in completions), (
        f"--arg-b should not appear in subcommand-a context, got: {completions}"
    )

    # Test 3: After selecting subcommand-b, should see exactly its options.
    completions = tester.get_completions(["prog", subcmd_b, ""], 2)
    expected_subcmd_b = {"-h", "--help", "--subcommand.arg-b"}
    assert set(completions) == expected_subcmd_b, (
        f"SubcommandB completions mismatch.\nExpected: {expected_subcmd_b}\nGot: {set(completions)}"
    )
    # Should not have subcommand-a's option.
    assert not any("arg-a" in c for c in completions), (
        f"--arg-a should not appear in subcommand-b context, got: {completions}"
    )


def test_zsh_functional_completion_simple(backend: str):
    """Test that zsh completion script is generated correctly."""

    # Skip if zsh is not available.
    if shutil.which("zsh") is None:
        pytest.skip("zsh not available")

    @dataclasses.dataclass
    class Config:
        mode: Literal["train", "eval", "test"] = "train"
        verbose: bool = False

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(Config, args=["--tyro-print-completion", "zsh"])

    completion_script = target.getvalue()

    # Verify the script structure is correct.
    assert "PYTHON_EOF" in completion_script or "_arguments" in completion_script
    assert "train" in completion_script or "eval" in completion_script


def test_cascade_marker_detection(backend: str):
    """Test that CascadeSubcommandArgs marker is properly detected in completion spec."""
    if backend != "tyro":
        pytest.skip("Cascade marker detection is tyro-specific")

    @dataclasses.dataclass
    class Config:
        regular_field: int = 5
        cascade_field: tyro.conf.CascadeSubcommandArgs[str] = "default"

    # Generate completion script.
    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(Config, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()

    # The completion spec is embedded in the script.
    # Verify it contains the fields and cascade info.
    assert "regular-field" in completion_script or "regular_field" in completion_script
    assert "cascade-field" in completion_script or "cascade_field" in completion_script

    # Verify the spec has cascade markers.
    # The cascade field should be tracked in the spec (using Python dict syntax with single quotes).
    assert "'cascade'" in completion_script


def test_nargs_with_choices_completion(backend: str):
    """Test that nargs is properly tracked for choice options in completion spec."""
    if backend != "tyro":
        pytest.skip("Choice nargs tracking is tyro-specific")

    @dataclasses.dataclass
    class Config:
        # Single choice.
        mode: Literal["train", "eval"] = "train"
        # Multiple choices.
        modes: List[Literal["train", "eval", "test"]] = dataclasses.field(
            default_factory=lambda: ["train"]
        )

    # Generate completion script.
    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(Config, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()

    # Verify completion spec has choices and nargs.
    assert "'choices'" in completion_script
    assert "train" in completion_script
    assert "eval" in completion_script
    assert "test" in completion_script

    # Verify nargs is tracked for the list field.
    assert "'nargs'" in completion_script


def test_metavar_in_description(backend: str):
    """Test that metavar is included in option descriptions."""
    if backend != "tyro":
        pytest.skip("Metavar formatting is tyro-specific")

    @dataclasses.dataclass
    class Config:
        count: int = 5
        name: str = "default"

    # Generate completion script.
    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(Config, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()

    # Verify metavar (type hints) appear in descriptions.
    # The descriptions should include INT and STR metavars.
    assert "INT" in completion_script or "int" in completion_script
    assert "STR" in completion_script or "str" in completion_script


@dataclasses.dataclass
class _ConfigForBulletTest:
    # No custom helptext, just default.
    simple: int = 5
    # Custom helptext.
    documented: int = 10
    """This is a custom help message."""


def test_smart_bullet_separator(backend: str):
    """Test that bullet separator is only used when there's custom helptext."""
    if backend != "tyro":
        pytest.skip("Bullet separator logic is tyro-specific")

    # Generate completion script.
    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(_ConfigForBulletTest, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()

    # Verify bullet separator (•) is used for fields with custom helptext.
    # The custom help message should have the bullet.
    assert "custom help" in completion_script.lower()
    assert "•" in completion_script


@dataclasses.dataclass
class _PreprocessingA:
    scale: float = 1.0


@dataclasses.dataclass
class _PreprocessingB:
    normalize: bool = True


@dataclasses.dataclass
class _AugmentationA:
    rotate: bool = True


@dataclasses.dataclass
class _AugmentationB:
    flip: bool = False


@dataclasses.dataclass
class _DatasetMNIST:
    """Dataset with its own frontier groups."""

    preprocessing: Union[_PreprocessingA, _PreprocessingB]
    augmentation: Union[_AugmentationA, _AugmentationB]


@dataclasses.dataclass
class _DatasetImageNet:
    resolution: int = 224


@dataclasses.dataclass
class _SubcommandWithFrontier:
    """A subcommand that has subcommands, one of which has frontier groups."""

    dataset: Union[_DatasetMNIST, _DatasetImageNet]


@dataclasses.dataclass
class _NestedMainCommand:
    # This creates a subcommand that has frontier groups.
    config: _SubcommandWithFrontier


def test_nested_subcommand_coverage(backend: str):
    """Test nested subcommands for coverage of _build_subcommand_spec recursion."""
    if backend != "tyro":
        pytest.skip("Testing tyro-specific completion generation")

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(_NestedMainCommand, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()
    # Verify nested subcommands are present.
    assert "config" in completion_script
    # Check for deeply nested frontier groups within subcommands.
    assert "dataset" in completion_script or "preprocessing" in completion_script


def test_positional_argument_coverage(backend: str):
    """Test that positional arguments are skipped in completion spec."""
    if backend != "tyro":
        pytest.skip("Testing tyro-specific completion generation")

    def main(input_file: tyro.conf.Positional[str], output: str = "out.txt") -> str:
        """Test with positional argument.

        Args:
            input_file: Input file path (positional).
            output: Output file path.
        """
        return f"{input_file} -> {output}"

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(main, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()
    # Positional args shouldn't appear in options list, only regular flags.
    assert "--output" in completion_script


def test_count_action_coverage(backend: str):
    """Test count action type for coverage."""
    if backend != "tyro":
        pytest.skip("Testing tyro-specific completion generation")

    def main(verbose: tyro.conf.UseCounterAction[int]) -> int:
        """Test function with counter action.

        Args:
            verbose: Verbosity level.
        """
        return verbose

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(main, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()
    # Count action creates a flag-type option.
    assert "flag" in completion_script.lower() or "verbose" in completion_script


def test_metavar_and_helptext_edge_cases(backend: str):
    """Test that completion works even with minimal help text."""
    if backend != "tyro":
        pytest.skip("Testing tyro-specific completion generation")

    def main(value: int = 5, flag: bool = False) -> int:
        """Test completion with basic arguments."""
        return value

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(main, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()
    # Verify basic completion generation works.
    assert "value" in completion_script or "flag" in completion_script


def test_unsupported_shell_error(backend: str):
    """Test that unsupported shell types raise an error."""
    if backend != "tyro":
        pytest.skip("Testing tyro-specific error handling")

    def main(value: int = 5) -> int:
        """Test function."""
        return value

    # Test that tcsh (supported by argparse but not tyro) raises ValueError.
    with pytest.raises(ValueError, match="Unsupported shell.*tcsh"):
        tyro.cli(main, args=["--tyro-print-completion", "tcsh"])


def test_deeply_nested_subcommand_completion(backend: str):
    """Test completion for subcommands at depth >= 2.

    This tests that the completion context correctly navigates into nested
    subcommands. Previously, there was a bug where the code checked the root
    spec instead of the current spec when determining if a word is a subcommand.

    See: https://github.com/brentyi/tyro/pull/407
    """
    if backend != "tyro":
        pytest.skip("Testing tyro-specific completion behavior")

    # Create nested subcommand structure: root -> level1 -> level2.
    @dataclasses.dataclass
    class Level2A:
        level2_opt: int = 1

    @dataclasses.dataclass
    class Level2B:
        level2_opt: int = 2

    @dataclasses.dataclass
    class Level1A:
        nested: Union[Level2A, Level2B]

    @dataclasses.dataclass
    class Level1B:
        other: str = "x"

    @dataclasses.dataclass
    class Root:
        child: Union[Level1A, Level1B]

    # Generate completion script.
    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(Root, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()
    tester = BashCompletionTester(completion_script)

    # Test 1: At root level, should see exactly level1 subcommands and help.
    completions = tester.get_completions(["prog", ""], 1)
    level1a_name = next((c for c in completions if "level1-a" in c.lower()), None)
    level1b_name = next((c for c in completions if "level1-b" in c.lower()), None)
    assert level1a_name is not None, f"level1-a not found in {completions}"
    assert level1b_name is not None, f"level1-b not found in {completions}"

    expected_root = {"-h", "--help", level1a_name, level1b_name}
    assert set(completions) == expected_root, (
        f"Root completions mismatch.\nExpected: {expected_root}\nGot: {set(completions)}"
    )

    # Test 2: After selecting level1-a, should see exactly level2 subcommands and help.
    completions = tester.get_completions(["prog", level1a_name, ""], 2)
    level2a_name = next((c for c in completions if "level2-a" in c.lower()), None)
    level2b_name = next((c for c in completions if "level2-b" in c.lower()), None)
    assert level2a_name is not None, f"level2-a not found in {completions}"
    assert level2b_name is not None, f"level2-b not found in {completions}"

    expected_level1a = {"-h", "--help", level2a_name, level2b_name}
    assert set(completions) == expected_level1a, (
        f"Level1A completions mismatch.\nExpected: {expected_level1a}\nGot: {set(completions)}"
    )
    # Should not have level1b's --other option.
    assert "--other" not in completions, "--other should not appear in level1-a context"

    # Test 3: After selecting level1-a and level2-a, should see exactly level2's options.
    # This is the case that was broken before the fix - it would show level2 subcommands again.
    completions = tester.get_completions(["prog", level1a_name, level2a_name, ""], 3)
    # Options have full prefix like --child.nested.level2-opt.
    expected_level2a = {"-h", "--help", "--child.nested.level2-opt"}
    assert set(completions) == expected_level2a, (
        f"Level2A completions mismatch.\nExpected: {expected_level2a}\nGot: {set(completions)}"
    )
    # Should not have level2 subcommands anymore (the bug showed these).
    assert level2a_name not in completions and level2b_name not in completions, (
        f"Subcommands should not appear after selecting level2, got: {completions}"
    )

    # Test 4: Verify level1-b shows its own options, not level1-a's nested subcommands.
    completions = tester.get_completions(["prog", level1b_name, ""], 2)
    expected_level1b = {"-h", "--help", "--child.other"}
    assert set(completions) == expected_level1b, (
        f"Level1B completions mismatch.\nExpected: {expected_level1b}\nGot: {set(completions)}"
    )
    # Should not have level2 subcommands.
    assert level2a_name not in completions and level2b_name not in completions, (
        "Level2 subcommands should not appear in level1-b context"
    )


def test_nested_dataclass_completion(backend: str):
    """Test that nested dataclass fields are included in completion spec.

    This tests the case where a dataclass has a nested dataclass field (not a Union),
    which creates child parsers via child_from_prefix rather than subcommands.
    """

    @dataclasses.dataclass
    class OptimizerConfig:
        learning_rate: float = 3e-4
        weight_decay: float = 1e-2

    @dataclasses.dataclass
    class Config:
        opt: OptimizerConfig
        seed: int = 0

    target = io.StringIO()
    with pytest.raises(SystemExit), contextlib.redirect_stdout(target):
        tyro.cli(Config, args=["--tyro-print-completion", "bash"])

    completion_script = target.getvalue()

    # Verify that the top-level argument is present.
    assert "--seed" in completion_script

    # Verify that nested arguments are present with their prefix.
    assert "--opt.learning-rate" in completion_script
    assert "--opt.weight-decay" in completion_script


def test_reconstruct_colon_words_basic():
    """Test basic word reconstruction for colon-separated subcommands."""
    from tyro._backends._completion._completion_script import reconstruct_colon_words

    # Spec with colon-separated subcommands.
    spec = {
        "subcommands": {
            "dataset:mnist": {},
            "dataset:image-net": {},
            "optimizer:adam": {},
        }
    }

    # Test 1: Basic reconstruction of "dataset:mnist".
    # Bash splits this as ["dataset", ":", "mnist"].
    words = ["dataset", ":", "mnist"]
    reconstructed, new_cword = reconstruct_colon_words(words, 2, spec)
    assert reconstructed == ["dataset:mnist"]
    assert new_cword == 0

    # Test 2: Partial completion "dataset:".
    # Bash splits this as ["dataset", ":"].
    words = ["dataset", ":"]
    reconstructed, new_cword = reconstruct_colon_words(words, 1, spec)
    assert reconstructed == ["dataset:"]
    assert new_cword == 0

    # Test 3: Partial prefix "dataset:m".
    # Bash splits this as ["dataset", ":", "m"].
    words = ["dataset", ":", "m"]
    reconstructed, new_cword = reconstruct_colon_words(words, 2, spec)
    assert reconstructed == ["dataset:m"]
    assert new_cword == 0


def test_reconstruct_colon_words_no_match():
    """Test that words are not reconstructed when they don't match subcommands."""
    from tyro._backends._completion._completion_script import reconstruct_colon_words

    spec = {"subcommands": {"dataset:mnist": {}}}

    # Test 1: Non-matching colon pattern (e.g., option value "key:value").
    # Should not be merged since "key:value" is not a known subcommand.
    words = ["--config", "key", ":", "value"]
    reconstructed, new_cword = reconstruct_colon_words(words, 3, spec)
    # Since "key:value" doesn't match any subcommand, keep them separate.
    # Standalone colons are skipped.
    assert reconstructed == ["--config", "key", "value"]
    assert new_cword == 2


def test_reconstruct_colon_words_multiple():
    """Test reconstruction with multiple colon-separated subcommands."""
    from tyro._backends._completion._completion_script import reconstruct_colon_words

    spec = {
        "subcommands": {
            "dataset:mnist": {},
            "optimizer:adam": {},
        }
    }

    # Test: Multiple subcommands "dataset:mnist optimizer:adam".
    # Bash splits as ["dataset", ":", "mnist", "optimizer", ":", "adam"].
    words = ["dataset", ":", "mnist", "optimizer", ":", "adam"]
    reconstructed, new_cword = reconstruct_colon_words(words, 5, spec)
    assert reconstructed == ["dataset:mnist", "optimizer:adam"]
    assert (
        new_cword == 1
    )  # Cursor on "adam" -> after reconstruction it's on second word.


def test_reconstruct_colon_words_with_options():
    """Test reconstruction with flags mixed in."""
    from tyro._backends._completion._completion_script import reconstruct_colon_words

    spec = {
        "subcommands": {
            "dataset:mnist": {},
        }
    }

    # Test: Subcommand with options "dataset:mnist --lr 0.001".
    # Bash splits as ["dataset", ":", "mnist", "--lr", "0.001"].
    words = ["dataset", ":", "mnist", "--lr", "0.001"]
    reconstructed, new_cword = reconstruct_colon_words(words, 4, spec)
    assert reconstructed == ["dataset:mnist", "--lr", "0.001"]
    assert new_cword == 2  # Cursor on "0.001" -> after merging, it's at index 2.


def test_reconstruct_colon_words_cursor_on_colon():
    """Test cursor position when it's on the colon itself."""
    from tyro._backends._completion._completion_script import reconstruct_colon_words

    spec = {"subcommands": {"dataset:mnist": {}}}

    # Test: Cursor is on the colon character.
    # Words: ["dataset", ":"], cursor at index 1 (the colon).
    words = ["dataset", ":"]
    reconstructed, new_cword = reconstruct_colon_words(words, 1, spec)
    # The colon should be merged with "dataset" to form "dataset:".
    assert reconstructed == ["dataset:"]
    # Cursor should be on the merged word.
    assert new_cword == 0


def test_reconstruct_colon_words_empty():
    """Test reconstruction with empty word list."""
    from tyro._backends._completion._completion_script import reconstruct_colon_words

    spec = {"subcommands": {}}

    # Empty word list.
    words = []
    reconstructed, new_cword = reconstruct_colon_words(words, 0, spec)
    assert reconstructed == []
    assert new_cword == 0
