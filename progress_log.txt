# Tyro Parser Refactoring Progress Log

## Goal
Remove the `subparsers: SubparsersSpecification | None` field from `ParserSpecification` and use only `subparsers_from_intern_prefix: Dict[str, SubparsersSpecification]` for tracking subparser groups.

## Motivation
1. **Performance**: The old approach called `add_subparsers_to_leaves()` during construction, which had O(k × m^n) complexity where k is the number of subparser groups, m is the average branching factor, and n is the nesting depth.
2. **Architecture**: There are two backends:
   - **Argparse backend**: Needs a materialized tree structure for argparse
   - **Custom tyro backend**: Can work with a flat dict without materializing the tree

   The key insight: Tree building should only happen in the argparse backend when needed, not during ParserSpecification construction.

## Design Decisions
1. Keep `ParserSpecification` backend-agnostic by removing the `subparsers` field
2. Create `MaterializedParserTree` and `MaterializedSubparsersTree` data structures for argparse-specific tree building
3. Build the materialized tree on-demand in the argparse backend, not during construction
4. Test argparse backend first (using `BACKEND: Literal["argparse", "tyro"] = "argparse"` in _cli.py)
5. Implement frontier-based approach for tyro backend later

## Key Technical Concepts

### Two Types of Subparser Nesting
1. **Nested subcommands**: `Union[A, Union[B, C]]` - subcommands within subcommands (handled recursively in materialized tree)
2. **Nested parsers with subcommands**: A field like `experiment_config: Union[Small, Big]` where the parent dataclass has subcommands that need to be accessible at the parent level (handled by flattening `subparsers_from_intern_prefix` from children into parent)

### Materialized Tree Structure
```python
@dataclasses.dataclass(frozen=True)
class MaterializedParserTree:
    parser_spec: ParserSpecification
    subparsers: MaterializedSubparsersTree | None  # Recursive!

@dataclasses.dataclass(frozen=True)
class MaterializedSubparsersTree:
    subparser_spec: SubparsersSpecification
    parser_tree_from_name: Dict[str, MaterializedParserTree]
```

The materialized tree is built by `build_parser_subparsers()` which:
1. Iterates over `parser_spec.subparsers_from_intern_prefix.values()`
2. Calls `add_subparsers_to_leaves()` to build the nested tree structure
3. Recursively builds subparsers for each parser in the tree

## Implementation Changes

### 1. Removed from ParserSpecification (src/tyro/_parsers.py)
- Removed `subparsers: SubparsersSpecification | None` field (line ~53)
- Removed construction-time tree building:
  - Deleted `add_subparsers_to_leaves()` call during construction (line ~158)
  - Deleted nested parser subparser flattening logic (lines ~168-174)
- Removed `set_subparser_parents()` function and its call (lines ~215-234)

### 2. Added Materialized Tree Structures (src/tyro/_parsers.py)
- Created `MaterializedParserTree` and `MaterializedSubparsersTree` dataclasses
- Implemented `build_parser_subparsers()` to build tree on-demand
- Updated `add_subparsers_to_leaves()` to work with materialized structures and recursively handle nested subparsers
- Added helper methods:
  - `_apply_materialized_subparsers()`: Apply a materialized subparser tree to argparse
  - `_apply_parser_with_materialized_subparsers()`: Apply a parser with pre-materialized subparsers

### 3. Updated ParserSpecification.apply() (src/tyro/_parsers.py, line ~222)
```python
root_subparsers = build_parser_subparsers(self)
if root_subparsers is not None:
    leaves = self._apply_materialized_subparsers(
        root_subparsers, parser, force_required_subparsers
    )
```

### 4. Flattened Subparsers from Nested Parsers (src/tyro/_parsers.py, line ~158)
When a field's type has subcommands (e.g., `experiment_config: Union[Small, Big]`), those subcommands need to be accessible at the parent level:
```python
# Flatten subparsers from nested parser into current parser.
for prefix, subparser_spec in nested_parser.subparsers_from_intern_prefix.items():
    subparsers_from_prefix[prefix] = subparser_spec
```

### 5. Fixed Argparse Backend (src/tyro/_backends/_argparse_backend.py)
- Added missing `add_help=parser_spec.add_help` parameter when creating TyroArgumentParser (line ~61)

### 6. Updated Helptext Formatting (src/tyro/_backends/_help_formatting.py)
- Updated `format_help()` signature to accept `materialized_subparsers: MaterializedSubparsersTree | None`
- Modified all references to `parser.subparsers` to use `build_parser_subparsers(parser)` or the provided materialized tree
- Updated sections:
  - consolidate_subcommand_args check (lines ~33-38)
  - Subparser metavar width calculation (lines ~84-98)
  - Subcommand display section (lines ~152-199)
  - Help flag suffix for consolidate_subcommand_args (lines ~297-305)
  - Recursive subparser search in error messages (lines ~349-367)

### 7. Attached Materialized Trees to Argparse Parsers (src/tyro/_parsers.py, line ~343)
Each argparse subparser gets the materialized tree attached for helptext generation:
```python
subparser._materialized_subparsers = parser_tree.subparsers
```

### 8. Updated format_help() Call (src/tyro/_backends/_argparse_formatter.py, line ~80)
```python
def format_help(self) -> str:
    materialized_subparsers = getattr(self, "_materialized_subparsers", None)
    return "\n".join(
        format_help(self._parser_specification, self.prog, materialized_subparsers)
    )
```

### 9. Temporarily Commented Out Tyro Backend
- Commented out usages of `.subparsers` in `src/tyro/_backends/_tyro_backend.py` (14 errors)
- These will need to be re-implemented with frontier-based approach later

## Test Results

### Current Status: 1600/1604 tests passing (99.75%)

### All 13 add_help tests: ✅ PASSING
### All 10 nested subparser tests: ✅ PASSING
### tests/test_base_configs_nested_exclude_py313.py (5 tests): ✅ PASSING

### Remaining Failures (4 tests total, 2 unique issues):

#### 1. test_multiple_subparsers_helptext (2 tests including py311)
File: tests/test_helptext.py::test_multiple_subparsers_helptext
Status: PARTIALLY FIXED

Fixed:
- ✅ Optional subcommands (c) now show at intermediate nodes (after selecting a:sub1 b:sub1)
- ✅ Default value shows: "(default: c:subcommand3)"
- ✅ Subcommand choices appear in usage and subcommands section

Remaining issues:
- ❌ Field description "# Field c description." not appearing in helptext
  - Root cause: `SubparsersSpecification.description` is None
  - The field's docstring/comment should be captured but isn't
- ❌ With `ConsolidateSubcommandArgs`, the root-level `d: bool` argument isn't being pushed to leaf subparsers
  - This may be a different issue with how ConsolidateSubcommandArgs interacts with multiple nested subparsers

#### 2. test_nargs_then_subcommand (2 tests including py311)
File: tests/test_nested.py::test_nargs_then_subcommand
Status: FAILING

Test case:
```python
@dataclass
class Config:
    x: List[str]
    y: Union[SubconfigA, SubconfigB]

# Command: ["--x", "a", "b", "c", "y:subconfig-a"]
# Expected: Config(["a", "b", "c"], SubconfigA())
# Actual: Error "Required options were not provided: {y:subconfig-a,y:subconfig-b}"
```

Issue: Argparse consumes "y:subconfig-a" as part of the `--x` list argument, rather than recognizing it as a subcommand. This appears to be an argparse limitation with nargs='*' followed by a positional subcommand.

## Architecture Notes

### Multiple Union Fields at Same Level
When you have:
```python
@dataclass
class Config:
    a: Union[Sub1, Sub2]
    b: Union[Sub1, Sub2]
    c: Union[Sub1, Sub2] = field(default_factory=Sub2)
```

The materialized tree structure is:
```
Root
├─ a:sub1
│  └─ b:sub1
│     └─ c:sub1, c:sub2 (optional, default=c:sub2)
│  └─ b:sub2
│     └─ c:sub1, c:sub2 (optional, default=c:sub2)
├─ a:sub2
│  └─ b:sub1
│     └─ c:sub1, c:sub2 (optional, default=c:sub2)
│  └─ b:sub2
│     └─ c:sub1, c:sub2 (optional, default=c:sub2)
```

Each path through the tree represents a valid combination of subcommands.

### Helptext Generation at Intermediate Nodes
When `--help` is requested at an intermediate node (e.g., `a:sub1 b:sub1 --help`):
1. Argparse routes to the parser for `b:sub1`
2. That parser has `_parser_specification = <ParserSpec for Sub1 type>`
3. That parser has `_materialized_subparsers = <MaterializedSubparsersTree for c field>`
4. Our custom `format_help()` uses the materialized tree to show the optional `c` subcommands

## Next Steps

### Immediate (for argparse backend):
1. Investigate why `SubparsersSpecification.description` is None for field comments
2. Investigate ConsolidateSubcommandArgs interaction with multiple nested subparsers
3. Decide on approach for nargs + subcommand limitation (may need workaround or accept limitation)

### Future (for tyro backend):
1. Implement frontier-based parsing approach
2. Un-comment and update code in `_tyro_backend.py`
3. Allow flexible subcommand ordering
4. Consider removing `subparser_parent` field with stack-based approach

## Files Modified

### Core Changes:
- src/tyro/_parsers.py (main refactoring)
- src/tyro/_cli.py (added BACKEND constant)
- src/tyro/_backends/_argparse_backend.py (added add_help parameter)
- src/tyro/_backends/_argparse_formatter.py (pass materialized tree to format_help)
- src/tyro/_backends/_help_formatting.py (use materialized trees instead of .subparsers)

### Temporarily Modified:
- src/tyro/_backends/_tyro_backend.py (commented out .subparsers usages)

## Performance Impact
- Construction time: O(n) instead of O(k × m^n) where n is number of fields
- Tree building: O(k × m^n) but only happens once in argparse backend when needed
- For tyro backend: No tree building needed, just O(k) dict access

## Git Status at Start
```
Modified: src/tyro/_backends/_argparse_backend.py
Modified: src/tyro/_backends/_help_formatting.py
Modified: src/tyro/_backends/_tyro_backend.py
Modified: src/tyro/_cli.py
Modified: src/tyro/_parsers.py
Untracked: mise.toml
Untracked: src/tyro/extras/_experimental_flags.py
```

## Testing Commands
```bash
# Run all tests
pytest tests/ --tb=no -q

# Run subcommand/nested tests
pytest tests/ -k "subcommand or helptext or nested" --tb=no -q

# Run specific failing tests
pytest tests/test_helptext.py::test_multiple_subparsers_helptext -xvs
pytest tests/test_nested.py::test_nargs_then_subcommand -xvs

# Regenerate py311 test variants after changes
python tests/test_py311_generated/_generate.py

# Type checking
pyright .

# Linting
ruff check
ruff format --diff
```
