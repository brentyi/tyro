:orphan:

:py:mod:`tyro._cli`
===================

.. py:module:: tyro._cli

.. autoapi-nested-parse::

   
   Core public API.


Module Contents
---------------

.. py:data:: OutT

   

.. py:function:: cli(f: tyro._typing.TypeForm[OutT], *, prog: Optional[str] = None, description: Optional[str] = None, args: Optional[Sequence[str]] = None, default: Optional[OutT] = None, return_unknown_args: typing_extensions.Literal[False] = False, use_underscores: bool = False) -> OutT
                 cli(f: tyro._typing.TypeForm[OutT], *, prog: Optional[str] = None, description: Optional[str] = None, args: Optional[Sequence[str]] = None, default: Optional[OutT] = None, return_unknown_args: typing_extensions.Literal[True], use_underscores: bool = False) -> Tuple[OutT, List[str]]
                 cli(f: Callable[Ellipsis, OutT], *, prog: Optional[str] = None, description: Optional[str] = None, args: Optional[Sequence[str]] = None, default: None = None, return_unknown_args: typing_extensions.Literal[False] = False, use_underscores: bool = False) -> OutT
                 cli(f: Callable[Ellipsis, OutT], *, prog: Optional[str] = None, description: Optional[str] = None, args: Optional[Sequence[str]] = None, default: None = None, return_unknown_args: typing_extensions.Literal[True], use_underscores: bool = False) -> Tuple[OutT, List[str]]

   
   Call or instantiate ``f``\ , with inputs populated from an automatically generated
   CLI interface.

   ``f`` should have type-annotated inputs, and can be a function or type. Note that if
   ``f`` is a type, ``tyro.cli()`` returns an instance.

   The parser is generated by populating helptext from docstrings and types from
   annotations; a broad range of core type annotations are supported.


   * Types natively accepted by ``argparse``\ : str, int, float, pathlib.Path, etc.
   * Default values for optional parameters.
   * Booleans, which are automatically converted to flags when provided a default
     value.
   * Enums (via ``enum.Enum``\ ).
   * Various annotations from the standard typing library. Some examples:

     * ``typing.ClassVar[T]``.
     * ``typing.Optional[T]``.
     * ``typing.Literal[T]``.
     * ``typing.Sequence[T]``.
     * ``typing.List[T]``.
     * ``typing.Dict[K, V]``.
     * ``typing.Tuple``\ , such as ``typing.Tuple[T1, T2, T3]`` or
       ``typing.Tuple[T, ...]``.
     * ``typing.Set[T]``.
     * ``typing.Final[T]`` and ``typing.Annotated[T]``.
     * ``typing.Union[T1, T2]``.
     * Various nested combinations of the above: ``Optional[Literal[T]]``\ ,
       ``Final[Optional[Sequence[T]]]``\ , etc.

   * Hierarchical structures via nested dataclasses, TypedDict, NamedTuple,
     classes.

     * Simple nesting.
     * Unions over nested structures (subparsers).
     * Optional unions over nested structures (optional subparsers).

   * Generics (including nested generics).

   Completion script generation for interactive shells is also provided. To write a
   script that can be used for tab completion, pass in:
       ``--tyro-write-completion {bash/zsh/tcsh} {path to script to write}``.

   :param f: Function or type.
   :param prog: The name of the program printed in helptext. Mirrors argument from
                ``argparse.ArgumentParser()``.
   :param description: Description text for the parser, displayed when the --help flag is
                       passed in. If not specified, ``f``\ 's docstring is used. Mirrors argument from
                       ``argparse.ArgumentParser()``.
   :param args: If set, parse arguments from a sequence of strings instead of the
                commandline. Mirrors argument from ``argparse.ArgumentParser.parse_args()``.
   :param default: An instance of ``OutT`` to use for default values; supported if ``f`` is a
                   type like a dataclass or dictionary, but not if ``f`` is a general callable like
                   a function or standard class. Helpful for merging CLI arguments with values
                   loaded from elsewhere. (for example, a config object loaded from a yaml file)
   :param return_unknown_args: If True, return a tuple of the output of ``f`` and a list of
                               unknown arguments. Mirrors the unknown arguments returned from
                               ``argparse.ArgumentParser.parse_known_args()``.
   :param use_underscores: If True, use underscores as a word delimeter instead of hyphens.
                           This primarily impacts helptext; underscores and hyphens are treated equivalently
                           when parsing happens. We default helptext to hyphens to follow the GNU style guide.
                           https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html

   :returns: The output of ``f(...)`` or an instance ``f``. If ``f`` is a class, the two are
             equivalent. If ``return_unknown_args`` is True, returns a tuple of the output of
             ``f(...)`` and a list of unknown arguments.

.. py:function:: get_parser(f: tyro._typing.TypeForm[OutT], *, prog: Optional[str] = None, description: Optional[str] = None, default: Optional[OutT] = None, use_underscores: bool = False) -> argparse.ArgumentParser
                 get_parser(f: Callable[Ellipsis, OutT], *, prog: Optional[str] = None, description: Optional[str] = None, default: Optional[OutT] = None, use_underscores: bool = False) -> argparse.ArgumentParser

   
   Get the ``argparse.ArgumentParser`` object generated under-the-hood by
   ``tyro.cli()``. Useful for tools like ``sphinx-argparse``\ , ``argcomplete``\ , etc.

   For tab completion, we recommend using ``tyro.cli()``\ 's built-in ``--tyro-write-completion``
   flag.

