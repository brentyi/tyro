:py:mod:`tyro.extras`
=====================

.. py:module:: tyro.extras

.. autoapi-nested-parse::

   
   The :mod:`tyro.extras` submodule contains helpers that complement :func:`tyro.cli()`.

   Compared to the core interface, APIs here are more likely to be changed or deprecated.


Package Contents
----------------

.. py:function:: set_accent_color(accent_color: Optional[str]) -> None

   
   Set an accent color to use in help messages. Takes any color supported by ``rich``\ ,
   see ``python -m rich.color``. Experimental.

.. py:function:: get_parser(f: tyro._typing.TypeForm[OutT], *, prog: Optional[str] = None, description: Optional[str] = None, default: Optional[OutT] = None, use_underscores: bool = False, console_outputs: bool = True) -> tyro._argparse.ArgumentParser
                 get_parser(f: Callable[Ellipsis, OutT], *, prog: Optional[str] = None, description: Optional[str] = None, default: Optional[OutT] = None, use_underscores: bool = False, console_outputs: bool = True) -> tyro._argparse.ArgumentParser

   
   Get the ``argparse.ArgumentParser`` object generated under-the-hood by
   ``tyro.cli()``. Useful for tools like ``sphinx-argparse``\ , ``argcomplete``\ , etc.

   For tab completion, we recommend using ``tyro.cli()``\ 's built-in ``--tyro-write-completion``
   flag.

.. py:function:: subcommand_type_from_defaults(defaults: Mapping[str, T], descriptions: Mapping[str, str] = {}, *, prefix_names: bool = True) -> tyro._typing.TypeForm[T]

   
   Construct a Union type for defining subcommands that choose between defaults.

   For example, when ``defaults`` is set to:

   .. code-block:: python

      {
          "small": Config(...),
          "big": Config(...),
      }

   We return:

   .. code-block:: python

      Union[
          Annotated[
              Config,
              tyro.conf.subcommand("small", default=Config(...))
          ],
          Annotated[
              Config,
              tyro.conf.subcommand("big", default=Config(...))
          ]
      ]

   Direct use of ``typing.Union`` and :func:`tyro.conf.subcommand()` should generally be
   preferred, but this function can be helpful for succinctness.

   .. warning::
       The type returned by this function can be safely used as an input to
       :func:`tyro.cli()`, but for static analysis when used for annotations we
       recommend applying a `TYPE_CHECKING` guard:

       .. code-block:: python

           from typing import TYPE_CHECKING

           if TYPE_CHECKING:
               # Static type seen by language servers, type checkers, etc.
               SelectableConfig = Config
           else:
               # Runtime type used by tyro.
               SelectableConfig = subcommand_type_from_defaults(...)

   :param defaults: A dictionary of default subcommand instances.
   :param descriptions: A dictionary conttaining descriptions for helptext.
   :param prefix_names: Whether to prefix subcommand names.

   :returns: A subcommand type, which can be passed to :func:`tyro.cli`.

.. py:function:: literal_type_from_choices(choices: Iterable[T]) -> tyro._typing.TypeForm[T]

   
   Generate a ``typing.Literal[]`` type that constrains values to a set of choices.

   Using ``Literal[...]`` directly should generally be preferred, but this function can be
   helpful when choices are generated dynamically.

   .. warning::
       The type returned by this function can be safely used as an input to
       :func:`tyro.cli()`, but for static analysis when used for annotations we
       recommend applying a `TYPE_CHECKING` guard:

       .. code-block:: python

           from typing import TYPE_CHECKING

           if TYPE_CHECKING:
               # Static type seen by language servers, type checkers, etc.
               Color = str
           else:
               # Runtime type used by tyro.
               Color = literal_type_from_choices(["red", "green", "blue"])

   :param choices: Options to choose from.

   :returns: A type that can be passed to :func:`tyro.cli()`.

.. py:function:: from_yaml(cls: Type[DataclassType], stream: Union[str, IO[str], bytes, IO[bytes]]) -> DataclassType

   
   Re-construct a dataclass instance from a yaml-compatible string, which should be
   generated from ``tyro.extras.to_yaml()``.

   As a secondary feature aimed at enabling the use of :func:`tyro.cli` for general
   configuration use cases, we also introduce functions for human-readable dataclass
   serialization: :func:`tyro.extras.from_yaml` and :func:`tyro.extras.to_yaml` attempt
   to strike a balance between flexibility and robustness — in contrast to naively
   dumping or loading dataclass instances (via pickle, PyYAML, etc), explicit type
   references enable custom tags that are robust against code reorganization and
   refactor, while a PyYAML backend enables serialization of arbitrary Python objects.

   .. warning::
       Serialization functionality is stable but deprecated. It may be removed in a
       future version of :code:`tyro`.

   :param cls: Type to reconstruct.
   :param stream: YAML to read from.

   :returns: Instantiated dataclass.

.. py:function:: to_yaml(instance: Any) -> str

   
   Serialize a dataclass; returns a yaml-compatible string that can be deserialized
   via ``tyro.extras.from_yaml()``.

   As a secondary feature aimed at enabling the use of :func:`tyro.cli` for general
   configuration use cases, we also introduce functions for human-readable dataclass
   serialization: :func:`tyro.extras.from_yaml` and :func:`tyro.extras.to_yaml` attempt
   to strike a balance between flexibility and robustness — in contrast to naively
   dumping or loading dataclass instances (via pickle, PyYAML, etc), explicit type
   references enable custom tags that are robust against code reorganization and
   refactor, while a PyYAML backend enables serialization of arbitrary Python objects.

   .. warning::
       Serialization functionality is stable but deprecated. It may be removed in a
       future version of :code:`tyro`.

   :param instance: Dataclass instance to serialize.

   :returns: YAML string.

.. py:function:: subcommand_cli_from_dict(subcommands: Dict[str, Callable[Ellipsis, T]], *, prog: Optional[str] = None, description: Optional[str] = None, args: Optional[Sequence[str]] = None, use_underscores: bool = False) -> T
                 subcommand_cli_from_dict(subcommands: Dict[str, Callable[Ellipsis, Any]], *, prog: Optional[str] = None, description: Optional[str] = None, args: Optional[Sequence[str]] = None, use_underscores: bool = False) -> Any

   
   Generate a subcommand CLI from a dictionary of functions.

   For an input like:

   .. code-block:: python

      tyro.extras.subcommand_cli_from_dict(
          {
              "checkout": checkout,
              "commit": commit,
          }
      )

   This is internally accomplished by generating and calling:

   .. code-block:: python

      from typing import Annotated, Any, Union
      import tyro

      tyro.cli(
          Union[
              Annotated[
                  Any,
                  tyro.conf.subcommand(name="checkout", constructor=checkout),
              ],
              Annotated[
                  Any,
                  tyro.conf.subcommand(name="commit", constructor=commit),
              ],
          ]
      )

   :param subcommands: Dictionary that maps the subcommand name to function to call.
   :param prog: The name of the program printed in helptext. Mirrors argument from
                ``argparse.ArgumentParser()``.
   :param description: Description text for the parser, displayed when the --help flag is
                       passed in. If not specified, ``f``\ 's docstring is used. Mirrors argument from
                       ``argparse.ArgumentParser()``.
   :param args: If set, parse arguments from a sequence of strings instead of the
                commandline. Mirrors argument from ``argparse.ArgumentParser.parse_args()``.
   :param use_underscores: If True, use underscores as a word delimeter instead of hyphens.
                           This primarily impacts helptext; underscores and hyphens are treated equivalently
                           when parsing happens. We default helptext to hyphens to follow the GNU style guide.
                           https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html

