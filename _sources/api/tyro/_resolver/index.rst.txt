:orphan:

:py:mod:`tyro._resolver`
========================

.. py:module:: tyro._resolver

.. autoapi-nested-parse::

   
   Utilities for resolving types and forward references.


Module Contents
---------------

.. py:data:: TypeOrCallable

   

.. py:function:: unwrap_origin_strip_extras(typ: TypeOrCallable) -> TypeOrCallable

   
   Returns the origin, ignoring typing.Annotated, of typ if it exists. Otherwise,
   returns typ.

.. py:function:: is_dataclass(cls: Union[tyro._typing.TypeForm, Callable]) -> bool

   
   Same as ``dataclasses.is_dataclass``\ , but also handles generic aliases.

.. py:function:: resolve_generic_types(cls: TypeOrCallable) -> Tuple[TypeOrCallable, Dict[TypeVar, tyro._typing.TypeForm[Any]]]

   
   If the input is a class: no-op. If it's a generic alias: returns the origin
   class, and a mapping from typevars to concrete types.

.. py:function:: resolved_fields(cls: tyro._typing.TypeForm) -> List[dataclasses.Field]

   
   Similar to dataclasses.fields(), but includes dataclasses.InitVar types and
   resolves forward references.

.. py:function:: is_namedtuple(cls: tyro._typing.TypeForm) -> bool


.. py:function:: type_from_typevar_constraints(typ: TypeOrCallable) -> TypeOrCallable

   
   Try to concretize a type from a TypeVar's bounds or constraints. Identity if
   unsuccessful.

.. py:data:: TypeOrCallableOrNone

   

.. py:function:: unwrap_newtype_and_aliases(typ: TypeOrCallableOrNone) -> Tuple[TypeOrCallableOrNone, Optional[str]]


.. py:function:: unwrap_newtype_and_narrow_subtypes(typ: TypeOrCallable, default_instance: Any) -> TypeOrCallable

   
   Type narrowing: if we annotate as Animal but specify a default instance of Cat,
   we should parse as Cat.

   This should generally only be applied to fields used as nested structures, not
   individual arguments/fields. (if a field is annotated as Union[int, str], and a
   string default is passed in, we don't want to narrow the type to always be
   strings!)

.. py:function:: narrow_collection_types(typ: TypeOrCallable, default_instance: Any) -> TypeOrCallable

   
   TypeForm narrowing for containers. Infers types of container contents.

.. py:data:: STRIP_WRAPPER_TYPES

   

.. py:data:: MetadataType

   

.. py:function:: unwrap_annotated(typ: TypeOrCallable, search_type: tyro._typing.TypeForm[MetadataType]) -> Tuple[TypeOrCallable, Tuple[MetadataType, Ellipsis]]
                 unwrap_annotated(typ: TypeOrCallable, search_type: typing_extensions.Literal[all]) -> Tuple[TypeOrCallable, Tuple[Any, Ellipsis]]
                 unwrap_annotated(typ: TypeOrCallable, search_type: None = None) -> TypeOrCallable

   
   Helper for parsing typing.Annotated types.

   Examples:


   * int, int => (int, ())
   * Annotated[int, 1], int => (int, (1,))
   * Annotated[int, "1"], int => (int, ())

.. py:function:: apply_type_from_typevar(typ: TypeOrCallable, type_from_typevar: Dict[TypeVar, tyro._typing.TypeForm[Any]]) -> TypeOrCallable


.. py:function:: narrow_union_type(typ: TypeOrCallable, default_instance: Any) -> TypeOrCallable

   
   Narrow union types.

   This is a shim for failing more gracefully when we we're given a Union type that
   doesn't match the default value.

   In this case, we raise a warning, then add the type of the default value to the
   union. Loosely motivated by: https://github.com/brentyi/tyro/issues/20

.. py:function:: get_type_hints_with_backported_syntax(obj: Callable[Ellipsis, Any], include_extras: bool = False) -> Dict[str, Any]

   
   Same as ``typing.get_type_hints()``\ , but supports new union syntax (X | Y)
   and generics (list[str]) in older versions of Python.

