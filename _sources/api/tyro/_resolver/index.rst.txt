:orphan:

:py:mod:`tyro._resolver`
========================

.. py:module:: tyro._resolver

.. autoapi-nested-parse::

   
   Utilities for resolving types and forward references.


Module Contents
---------------

.. py:data:: TypeOrCallable

   

.. py:function:: unwrap_origin_strip_extras(typ: TypeOrCallable) -> TypeOrCallable

   
   Returns the origin, ignoring typing.Annotated, of typ if it exists. Otherwise,
   returns typ.

.. py:function:: is_dataclass(cls: Union[tyro._typing.TypeForm, Callable]) -> bool

   
   Same as ``dataclasses.is_dataclass``\ , but also handles generic aliases.

.. py:function:: resolve_generic_types(cls: TypeOrCallable) -> Tuple[TypeOrCallable, Dict[TypeVar, tyro._typing.TypeForm[Any]]]

   
   If the input is a class: no-op. If it's a generic alias: returns the origin
   class, and a mapping from typevars to concrete types.

.. py:function:: resolved_fields(cls: tyro._typing.TypeForm) -> List[dataclasses.Field]

   
   Similar to dataclasses.fields(), but includes dataclasses.InitVar types and
   resolves forward references.

.. py:function:: is_namedtuple(cls: tyro._typing.TypeForm) -> bool


.. py:function:: type_from_typevar_constraints(typ: TypeOrCallable) -> TypeOrCallable

   
   Try to concretize a type from a TypeVar's bounds or constraints. Identity if
   unsuccessful.

.. py:function:: narrow_subtypes(typ: TypeOrCallable, default_instance: Any) -> TypeOrCallable

   
   Type narrowing: if we annotate as Animal but specify a default instance of Cat,
   we should parse as Cat.

   This should generally only be applied to fields used as nested structures, not
   individual arguments/fields. (if a field is annotated as Union[int, str], and a
   string default is passed in, we don't want to narrow the type to always be
   strings!)

.. py:function:: narrow_collection_types(typ: TypeOrCallable, default_instance: Any) -> TypeOrCallable

   
   TypeForm narrowing for containers. Infers types of container contents.

.. py:data:: MetadataType

   

.. py:function:: unwrap_annotated(typ: TypeOrCallable, search_type: tyro._typing.TypeForm[MetadataType] = Any) -> Tuple[TypeOrCallable, Tuple[MetadataType, Ellipsis]]

   
   Helper for parsing typing.Annotated types.

   Examples:


   * int, int => (int, ())
   * Annotated[int, 1], int => (int, (1,))
   * Annotated[int, "1"], int => (int, ())

.. py:function:: apply_type_from_typevar(typ: TypeOrCallable, type_from_typevar: Dict[TypeVar, tyro._typing.TypeForm[Any]]) -> TypeOrCallable


.. py:function:: narrow_union_type(typ: TypeOrCallable, default_instance: Any) -> TypeOrCallable

   
   Narrow union types.

   This is a shim for failing more gracefully when we we're given one of two errors:
   (A) A Union type that doesn't match the default value.
   (B) An unsupported Union type, which mixes "nested" types (like dataclasses) with
     non-"nested" types (like strings).

   --
   For (A):

   We raise a warning, then add the type of the default value to the union.
   Loosely motivated by: https://github.com/brentyi/tyro/issues/20

   --
   For (B):

   When do we want to narrow Union types?

     Unions over nested types: no.
        typ = NestedA | NestedB
        => NestedA | NestedB can be converted to two subcommands.

     Unions over nested and not nested types: no.
        typ = int | str
        => int | str can be instantiated as a union.

     Unions over mixed nested / not nested types: if the default is a nested
     type, strip out the non-nested ones. If the default is a non-nested
     type, strip out the nested ones.

   ::

       typ = NestedA | int, default_instance = NestedA()
       => NestedA

       typ = NestedA | int, default_instance = 5
       => int

       typ = NestedA | NestedB | int, default_instance = NestedA()
       => NestedA


   This is a hack to get around the fact that we don't currently support
   mixing nested types (eg ``SomeDataclass``\ ) and non-nested ones (eg ``int`` or
   ``int | str``\ ) in unions. This should be supported in the future, but will
   likely require a big code refactor.

