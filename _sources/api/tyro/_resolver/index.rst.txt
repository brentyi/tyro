:orphan:

:py:mod:`tyro._resolver`
========================

.. py:module:: tyro._resolver

.. autoapi-nested-parse::

   Utilities for resolving types and forward references.



Module Contents
---------------

.. py:data:: TypeAliasTypeAlternate

   

.. py:data:: UnionType

   Same as types.UnionType, but points to typing.Union for older versions of
   Python. types.UnionType was added in Python 3.10, and is created when the `X |
   Y` syntax is used for unions.

.. py:data:: TypeOrCallable

   

.. py:class:: TyroTypeAliasBreadCrumb


   A breadcrumb we can leave behind to track names of type aliases and
   `NewType` types. We can use type alias names to auto-populate
   subcommands.

   .. py:attribute:: name
      :type: str

      


.. py:function:: unwrap_origin_strip_extras(typ: TypeOrCallable) -> TypeOrCallable

   Returns the origin, ignoring typing.Annotated, of typ if it exists. Otherwise,
   returns typ.


.. py:function:: is_dataclass(cls: Union[tyro._typing.TypeForm, Callable]) -> bool

   Same as `dataclasses.is_dataclass`, but also handles generic aliases.


.. py:function:: resolved_fields(cls: tyro._typing.TypeForm) -> List[dataclasses.Field]

   Similar to dataclasses.fields(), but includes dataclasses.InitVar types and
   resolves forward references.


.. py:function:: is_namedtuple(cls: tyro._typing.TypeForm) -> bool


.. py:data:: TypeOrCallableOrNone

   

.. py:function:: resolve_newtype_and_aliases(typ: TypeOrCallableOrNone) -> TypeOrCallableOrNone


.. py:function:: narrow_subtypes(typ: TypeOrCallable, default_instance: Any) -> TypeOrCallable

   Type narrowing: if we annotate as Animal but specify a default instance of Cat,
   we should parse as Cat.

   This should generally only be applied to fields used as nested structures, not
   individual arguments/fields. (if a field is annotated as Union[int, str], and a
   string default is passed in, we don't want to narrow the type to always be
   strings!)


.. py:function:: swap_type_using_confstruct(typ: TypeOrCallable) -> TypeOrCallable

   Swap types using the `constructor_factory` attribute from
   `tyro.conf.arg` and `tyro.conf.subcommand`. Runtime annotations are
   kept, but the type is swapped.


.. py:function:: narrow_collection_types(typ: TypeOrCallable, default_instance: Any) -> TypeOrCallable

   TypeForm narrowing for containers. Infers types of container contents.


.. py:data:: STRIP_WRAPPER_TYPES

   

.. py:data:: MetadataType

   

.. py:function:: unwrap_annotated(typ: TypeOrCallable, search_type: tyro._typing.TypeForm[MetadataType]) -> Tuple[TypeOrCallable, Tuple[MetadataType, Ellipsis]]
                 unwrap_annotated(typ: TypeOrCallable, search_type: Literal[all]) -> Tuple[TypeOrCallable, Tuple[Any, Ellipsis]]
                 unwrap_annotated(typ: TypeOrCallable, search_type: None = None) -> TypeOrCallable

   Helper for parsing typing.Annotated types.

   Examples:
   - int, int => (int, ())
   - Annotated[int, 1], int => (int, (1,))
   - Annotated[int, "1"], int => (int, ())


.. py:class:: TypeParamResolver


   .. py:attribute:: param_assignments
      :type: List[Dict[TypeVar, tyro._typing.TypeForm[Any]]]
      :value: []

      

   .. py:method:: get_assignment_context(typ: TypeOrCallable) -> TypeParamAssignmentContext
      :classmethod:

      Context manager for resolving type parameters.


   .. py:method:: concretize_type_params(typ: TypeOrCallable, seen: set[Any] | None = None) -> TypeOrCallable
      :staticmethod:

      Apply type parameter assignments based on the current context.



.. py:class:: TypeParamAssignmentContext(origin_type: TypeOrCallable, type_from_typevar: Dict[TypeVar, tyro._typing.TypeForm[Any]])


   .. py:method:: __enter__()


   .. py:method:: __exit__(exc_type, exc_value, traceback)



.. py:function:: expand_union_types(typ: TypeOrCallable, default_instance: Any) -> TypeOrCallable

   Expand union types if necessary.

   This is a shim for failing more gracefully when we we're given a Union type that
   doesn't match the default value.

   In this case, we raise a warning, then add the type of the default value to the
   union. Loosely motivated by: https://github.com/brentyi/tyro/issues/20


.. py:function:: isinstance_with_fuzzy_numeric_tower(obj: Any, classinfo: Type) -> Union[bool, Literal[~]]

   Enhanced version of isinstance() that returns:
   - True: if object is exactly of the specified type
   - "~": if object follows numeric tower rules but isn't exact type
   - False: if object is not of the specified type or numeric tower rules don't apply

   Examples:
   >>> enhanced_isinstance(3, int)       # Returns True
   >>> enhanced_isinstance(3, float)     # Returns "~"
   >>> enhanced_isinstance(True, int)    # Returns "~"
   >>> enhanced_isinstance(3, bool)      # Returns False
   >>> enhanced_isinstance(True, bool)   # Returns True


.. py:data:: NoneType

   

.. py:function:: resolve_generic_types(typ: TypeOrCallable) -> Tuple[TypeOrCallable, Dict[TypeVar, tyro._typing.TypeForm[Any]]]

   If the input is a class: no-op. If it's a generic alias: returns the origin
   class, and a mapping from typevars to concrete types.


.. py:function:: get_type_hints_resolve_type_params(obj: Callable[Ellipsis, Any], include_extras: bool = False) -> Dict[str, Any]

   Variant of `typing.get_type_hints()` that resolves type parameters.


.. py:function:: is_instance(typ: Any, value: Any) -> bool

   Typeguard-based alternative for `isinstance()`.


