:orphan:

:py:mod:`tyro._singleton`
=========================

.. py:module:: tyro._singleton


Module Contents
---------------

.. py:class:: Singleton


   .. py:method:: init(*args, **kwds)



.. py:class:: PropagatingMissingType(spec=None, side_effect=None, return_value=DEFAULT, wraps=None, name=None, spec_set=None, parent=None, _spec_state=None, _new_name='', _new_parent=None, **kwargs)


   Bases: :py:obj:`Singleton`, :py:obj:`unittest.mock.Mock`

   Create a new `Mock` object. `Mock` takes several optional arguments
   that specify the behaviour of the Mock object:

   * `spec`: This can be either a list of strings or an existing object (a
     class or instance) that acts as the specification for the mock object. If
     you pass in an object then a list of strings is formed by calling dir on
     the object (excluding unsupported magic attributes and methods). Accessing
     any attribute not in this list will raise an `AttributeError`.

     If `spec` is an object (rather than a list of strings) then
     `mock.__class__` returns the class of the spec object. This allows mocks
     to pass `isinstance` tests.

   * `spec_set`: A stricter variant of `spec`. If used, attempting to *set*
     or get an attribute on the mock that isn't on the object passed as
     `spec_set` will raise an `AttributeError`.

   * `side_effect`: A function to be called whenever the Mock is called. See
     the `side_effect` attribute. Useful for raising exceptions or
     dynamically changing return values. The function is called with the same
     arguments as the mock, and unless it returns `DEFAULT`, the return
     value of this function is used as the return value.

     If `side_effect` is an iterable then each call to the mock will return
     the next value from the iterable. If any of the members of the iterable
     are exceptions they will be raised instead of returned.

   * `return_value`: The value returned when the mock is called. By default
     this is a new Mock (created on first access). See the
     `return_value` attribute.

   * `unsafe`: By default, accessing any attribute whose name starts with
     *assert*, *assret*, *asert*, *aseert*, or *assrt* raises an AttributeError.
     Additionally, an AttributeError is raised when accessing
     attributes that match the name of an assertion method without the prefix
     `assert_`, e.g. accessing `called_once` instead of `assert_called_once`.
     Passing `unsafe=True` will allow access to these attributes.

   * `wraps`: Item for the mock object to wrap. If `wraps` is not None then
     calling the Mock will pass the call through to the wrapped object
     (returning the real result). Attribute access on the mock will return a
     Mock object that wraps the corresponding attribute of the wrapped object
     (so attempting to access an attribute that doesn't exist will raise an
     `AttributeError`).

     If the mock has an explicit `return_value` set then calls are not passed
     to the wrapped object and the `return_value` is returned instead.

   * `name`: If the mock has a name then it will be used in the repr of the
     mock. This can be useful for debugging. The name is propagated to child
     mocks.

   Mocks can also be called with arbitrary keyword arguments. These will be
   used to set attributes on the mock after it is created.


.. py:class:: NonpropagatingMissingType(spec=None, side_effect=None, return_value=DEFAULT, wraps=None, name=None, spec_set=None, parent=None, _spec_state=None, _new_name='', _new_parent=None, **kwargs)


   Bases: :py:obj:`Singleton`, :py:obj:`unittest.mock.Mock`

   Create a new `Mock` object. `Mock` takes several optional arguments
   that specify the behaviour of the Mock object:

   * `spec`: This can be either a list of strings or an existing object (a
     class or instance) that acts as the specification for the mock object. If
     you pass in an object then a list of strings is formed by calling dir on
     the object (excluding unsupported magic attributes and methods). Accessing
     any attribute not in this list will raise an `AttributeError`.

     If `spec` is an object (rather than a list of strings) then
     `mock.__class__` returns the class of the spec object. This allows mocks
     to pass `isinstance` tests.

   * `spec_set`: A stricter variant of `spec`. If used, attempting to *set*
     or get an attribute on the mock that isn't on the object passed as
     `spec_set` will raise an `AttributeError`.

   * `side_effect`: A function to be called whenever the Mock is called. See
     the `side_effect` attribute. Useful for raising exceptions or
     dynamically changing return values. The function is called with the same
     arguments as the mock, and unless it returns `DEFAULT`, the return
     value of this function is used as the return value.

     If `side_effect` is an iterable then each call to the mock will return
     the next value from the iterable. If any of the members of the iterable
     are exceptions they will be raised instead of returned.

   * `return_value`: The value returned when the mock is called. By default
     this is a new Mock (created on first access). See the
     `return_value` attribute.

   * `unsafe`: By default, accessing any attribute whose name starts with
     *assert*, *assret*, *asert*, *aseert*, or *assrt* raises an AttributeError.
     Additionally, an AttributeError is raised when accessing
     attributes that match the name of an assertion method without the prefix
     `assert_`, e.g. accessing `called_once` instead of `assert_called_once`.
     Passing `unsafe=True` will allow access to these attributes.

   * `wraps`: Item for the mock object to wrap. If `wraps` is not None then
     calling the Mock will pass the call through to the wrapped object
     (returning the real result). Attribute access on the mock will return a
     Mock object that wraps the corresponding attribute of the wrapped object
     (so attempting to access an attribute that doesn't exist will raise an
     `AttributeError`).

     If the mock has an explicit `return_value` set then calls are not passed
     to the wrapped object and the `return_value` is returned instead.

   * `name`: If the mock has a name then it will be used in the repr of the
     mock. This can be useful for debugging. The name is propagated to child
     mocks.

   Mocks can also be called with arbitrary keyword arguments. These will be
   used to set attributes on the mock after it is created.


.. py:class:: ExcludeFromCallType


   Bases: :py:obj:`Singleton`


.. py:class:: NotRequiredButWeDontKnowTheValueType


   Bases: :py:obj:`Singleton`


.. py:data:: MISSING
   :type: Any

   Sentinel value to mark default values as missing. Can be used to mark fields
   passed in via `default=` for `tyro.cli()` as required.

   When used, the 'missing' semantics propagate to children. For example, if we write:

   .. code-block:: python

       def main(inner: Dataclass = tyro.MISSING) -> None:
           ...

       tyro.cli(main)

   then all fields belonging to ``Dataclass`` will be marked as missing, even if a
   default exists in the dataclass definition.

.. py:data:: MISSING_NONPROP
   :type: Any

   Non-propagating version of :data:`tyro.MISSING`.

   When used, the 'missing' semantics do not propagate to children. For example:

   .. code-block:: python

       def main(inner: Dataclass = tyro.constructors.MISSING_NONPROP) -> None:
           ...

       tyro.cli(main)

   is equivalent to:

   .. code-block:: python

       def main(inner: Dataclass) -> None:
           ...

       tyro.cli(main)

   where default values for fields belonging to ``Dataclass`` will be taken from
   the dataclass definition.

.. py:data:: NOT_REQUIRED_BUT_WE_DONT_KNOW_THE_VALUE

   

.. py:data:: EXCLUDE_FROM_CALL

   

.. py:data:: MISSING_AND_MISSING_NONPROP
   :value: ()

   Singletons that are considered missing values when generating CLI interfaces.

.. py:data:: DEFAULT_SENTINEL_SINGLETONS

   

