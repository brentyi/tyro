:orphan:

:py:mod:`tyro._fields`
======================

.. py:module:: tyro._fields

.. autoapi-nested-parse::

   Abstractions for pulling out 'field' definitions, which specify inputs, types, and # type: ignore
   defaults, from general callables.



Module Contents
---------------

.. py:data:: global_context_markers
   :type: list[tuple[tyro.conf._markers.Marker, Ellipsis]]
   :value: []

   

.. py:class:: FieldDefinition


   .. py:attribute:: intern_name
      :type: str

      

   .. py:attribute:: extern_name
      :type: str

      

   .. py:attribute:: type
      :type: tyro._typing.TypeForm[Any] | Callable

      Full type, including runtime annotations.

   .. py:attribute:: type_stripped
      :type: tyro._typing.TypeForm[Any] | Callable

      

   .. py:attribute:: default
      :type: Any

      

   .. py:attribute:: helptext
      :type: str | None

      

   .. py:attribute:: markers
      :type: set[Any]

      

   .. py:attribute:: custom_constructor
      :type: bool

      

   .. py:attribute:: argconf
      :type: tyro.conf._confstruct._ArgConfig

      

   .. py:attribute:: mutex_group
      :type: tyro.conf._mutex_group._MutexGroupConfig | None

      

   .. py:attribute:: call_argname
      :type: Any

      

   .. py:method:: marker_context(markers: tuple[tyro.conf._markers.Marker, Ellipsis])
      :staticmethod:

      Context for setting markers on fields. All fields created within the
      context will have the specified markers.


   .. py:method:: from_field_spec(field_spec: tyro.constructors._struct_spec.StructFieldSpec) -> FieldDefinition
      :staticmethod:


   .. py:method:: make(name: str, typ: tyro._typing.TypeForm[Any] | Callable, default: Any, helptext: str | None, call_argname_override: Any | None = None)
      :staticmethod:


   .. py:method:: with_new_type_stripped(new_type_stripped: tyro._typing.TypeForm[Any] | Callable) -> FieldDefinition


   .. py:method:: is_positional_call() -> bool

      Returns True if the argument should be positional in underlying Python call.



.. py:function:: is_struct_type(typ: tyro._typing.TypeForm[Any] | Callable, default_instance: Any, in_union_context: bool) -> bool

   Determine whether a type should be treated as a 'struct type', where a single
   type can be broken down into multiple fields (eg for nested dataclasses or
   classes).

   The `in_union_context` flag indicates whether this type is being evaluated as part
   of a union. When True, allows collection types like List[Struct] or Dict[str, Struct]
   without defaults to be treated as struct types (for subcommand creation).


.. py:function:: field_list_from_type_or_callable(f: Callable | tyro._typing.TypeForm[Any], default_instance: Any, support_single_arg_types: bool, in_union_context: bool) -> tyro.constructors._struct_spec.UnsupportedStructTypeMessage | tyro.constructors._struct_spec.InvalidDefaultInstanceError | tuple[Callable | tyro._typing.TypeForm[Any], list[FieldDefinition]]

   Generate a list of generic 'field' objects corresponding to the inputs of some
   annotated callable.

   The `in_union_context` flag indicates whether this type is being evaluated as part
   of a union. When True, allows collection types like List[Struct] or Dict[str, Struct]
   without defaults to be treated as struct types (for subcommand creation).

   :returns: *- tuple[type, list[FieldDefinition]] if successful* -- the resolved type and its field definitions.
             - UnsupportedStructTypeMessage if the type cannot be treated as a struct (e.g., not a dataclass, function, etc.).
             - InvalidDefaultInstanceError if the type can be treated as a struct, but the provided default instance is incompatible with the type.


