:orphan:

:py:mod:`tyro._fields`
======================

.. py:module:: tyro._fields

.. autoapi-nested-parse::

   
   Abstractions for pulling out 'field' definitions, which specify inputs, types, and
   defaults, from general callables.


Module Contents
---------------

.. py:class:: FieldDefinition

   .. py:attribute:: name
      :annotation: :str

      

   .. py:attribute:: typ
      :annotation: :tyro._typing.TypeForm[Any]

      

   .. py:attribute:: default
      :annotation: :Any

      

   .. py:attribute:: helptext
      :annotation: :Optional[str]

      

   .. py:attribute:: markers
      :annotation: :FrozenSet[tyro.conf._markers._Marker]

      

   .. py:attribute:: argconf
      :annotation: :tyro.conf._confstruct._ArgConfiguration

      

   .. py:attribute:: call_argname
      :annotation: :Any

      

   .. py:method:: __post_init__(self)


   .. py:method:: make(name: str, typ: tyro._typing.TypeForm[Any], default: Any, helptext: Optional[str], call_argname_override: Optional[Any] = None, *, markers: Tuple[tyro.conf._markers._Marker, Ellipsis] = ())
      :staticmethod:


   .. py:method:: add_markers(self, markers: Tuple[tyro.conf._markers._Marker, Ellipsis]) -> FieldDefinition


   .. py:method:: is_positional(self) -> bool

      
      Returns True if the argument should be positional in the commandline.

   .. py:method:: is_positional_call(self) -> bool

      
      Returns True if the argument should be positional in underlying Python call.


.. py:class:: PropagatingMissingType

   Bases: :py:obj:`tyro._singleton.Singleton`


.. py:class:: NonpropagatingMissingType

   Bases: :py:obj:`tyro._singleton.Singleton`


.. py:class:: ExcludeFromCallType

   Bases: :py:obj:`tyro._singleton.Singleton`


.. py:data:: MISSING_PROP
   

   

.. py:data:: MISSING_NONPROP
   

   

.. py:data:: EXCLUDE_FROM_CALL
   

   

.. py:data:: MISSING
   :annotation: :Any

   
   Sentinel value to mark fields as missing. Can be used to mark fields passed in as a
   ``default_instance`` for ``tyro.cli()`` as required.

.. py:data:: MISSING_SINGLETONS
   

   

.. py:class:: UnsupportedNestedTypeMessage

   
   Reason why a callable cannot be treated as a nested type.
   .. py:attribute:: message
      :annotation: :str

      


.. py:function:: is_nested_type(typ: tyro._typing.TypeForm[Any], default_instance: DefaultInstance) -> bool

   
   Determine whether a type should be treated as a 'nested type', where a single
   type can be broken down into multiple fields (eg for nested dataclasses or
   classes).

   TODO: we should come up with a better name than 'nested type', which is a little bit
   misleading.

.. py:function:: field_list_from_callable(f: Union[Callable, tyro._typing.TypeForm[Any]], default_instance: DefaultInstance) -> Tuple[Union[Callable, tyro._typing.TypeForm[Any]], Dict[TypeVar, tyro._typing.TypeForm], List[FieldDefinition]]

   
   Generate a list of generic 'field' objects corresponding to the inputs of some
   annotated callable.

   :returns: The type that ``f`` is resolved as.
             A type_from_typevar dict.
             A list of field definitions.

.. py:data:: DefaultInstance
   

   

.. py:data:: pydantic
   

   

.. py:data:: attr
   

   

