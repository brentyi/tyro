:orphan:

:py:mod:`tyro._fields`
======================

.. py:module:: tyro._fields

.. autoapi-nested-parse::

   
   Abstractions for pulling out 'field' definitions, which specify inputs, types, and
   defaults, from general callables.


Module Contents
---------------

.. py:class:: FieldDefinition


   .. py:attribute:: intern_name
      :type: str

      

   .. py:attribute:: extern_name
      :type: str

      

   .. py:attribute:: type_or_callable
      :type: Union[tyro._typing.TypeForm[Any], Callable]

      
      Type or callable for this field. This should have all Annotated[] annotations
      stripped.

   .. py:attribute:: default
      :type: Any

      

   .. py:attribute:: helptext
      :type: Optional[str]

      

   .. py:attribute:: markers
      :type: FrozenSet[Any]

      

   .. py:attribute:: custom_constructor
      :type: bool

      

   .. py:attribute:: argconf
      :type: tyro.conf._confstruct._ArgConfiguration

      

   .. py:attribute:: call_argname
      :type: Any

      

   .. py:method:: __post_init__()


   .. py:method:: make(name: str, type_or_callable: Union[tyro._typing.TypeForm[Any], Callable], default: Any, helptext: Optional[str], call_argname_override: Optional[Any] = None, *, markers: Tuple[tyro.conf._markers._Marker, Ellipsis] = ())
      :staticmethod:


   .. py:method:: add_markers(markers: Tuple[Any, Ellipsis]) -> FieldDefinition


   .. py:method:: is_positional() -> bool

      
      Returns True if the argument should be positional in the commandline.

   .. py:method:: is_positional_call() -> bool

      
      Returns True if the argument should be positional in underlying Python call.


.. py:class:: PropagatingMissingType


   Bases: :py:obj:`tyro._singleton.Singleton`


.. py:class:: NonpropagatingMissingType


   Bases: :py:obj:`tyro._singleton.Singleton`


.. py:class:: ExcludeFromCallType


   Bases: :py:obj:`tyro._singleton.Singleton`


.. py:class:: NotRequiredButWeDontKnowTheValueType


   Bases: :py:obj:`tyro._singleton.Singleton`


.. py:data:: MISSING_PROP

   

.. py:data:: MISSING_NONPROP

   

.. py:data:: NOT_REQUIRED_BUT_WE_DONT_KNOW_THE_VALUE

   

.. py:data:: EXCLUDE_FROM_CALL

   

.. py:data:: MISSING
   :type: Any

   
   Sentinel value to mark fields as missing. Can be used to mark fields passed in as a
   ``default_instance`` for ``tyro.cli()`` as required.

.. py:data:: MISSING_SINGLETONS

   

.. py:data:: DEFAULT_SENTINEL_SINGLETONS

   

.. py:class:: UnsupportedNestedTypeMessage


   
   Reason why a callable cannot be treated as a nested type.
   .. py:attribute:: message
      :type: str

      


.. py:function:: is_nested_type(typ: Union[tyro._typing.TypeForm[Any], Callable], default_instance: DefaultInstance) -> bool

   
   Determine whether a type should be treated as a 'nested type', where a single
   type can be broken down into multiple fields (eg for nested dataclasses or
   classes).

   TODO: we should come up with a better name than 'nested type', which is a little bit
   misleading.

.. py:function:: field_list_from_callable(f: Union[Callable, tyro._typing.TypeForm[Any]], default_instance: DefaultInstance, support_single_arg_types: bool) -> Tuple[Union[Callable, tyro._typing.TypeForm[Any]], Dict[TypeVar, tyro._typing.TypeForm], List[FieldDefinition]]

   
   Generate a list of generic 'field' objects corresponding to the inputs of some
   annotated callable.

   :returns: The type that ``f`` is resolved as.
             A type_from_typevar dict.
             A list of field definitions.

.. py:data:: DefaultInstance

   

.. py:data:: pydantic

   

.. py:data:: attr

   

