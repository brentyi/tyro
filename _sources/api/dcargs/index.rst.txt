:py:mod:`dcargs`
================

.. py:module:: dcargs


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   extras/index.rst


Package Contents
----------------

.. py:function:: cli(f: Callable[Ellipsis, T], *, prog: Optional[str] = None, description: Optional[str] = None, args: Optional[Sequence[str]] = None, default_instance: Optional[T] = None, avoid_subparsers: bool = False) -> T

   
   Call ``f(...)``\ , with arguments populated from an automatically generated CLI
   interface.

   ``f`` should have type-annotated inputs, and can be a function or class. Note that if
   ``f`` is a class, ``dcargs.cli()`` returns an instance.

   The parser is generated by populating helptext from docstrings and types from
   annotations; a broad range of core type annotations are supported...


   * Types natively accepted by ``argparse``\ : str, int, float, pathlib.Path, etc.
   * Default values for optional parameters.
   * Booleans, which are automatically converted to flags when provided a default
     value.
   * Enums (via ``enum.Enum``\ ).
   * Various annotations from the standard typing library. Some examples:

     * ``typing.ClassVar[T]``.
     * ``typing.Optional[T]``.
     * ``typing.Literal[T]``.
     * ``typing.Sequence[T]``.
     * ``typing.List[T]``.
     * ``typing.Dict[K, V]``.
     * ``typing.Tuple``\ , such as ``typing.Tuple[T1, T2, T3]`` or
       ``typing.Tuple[T, ...]``.
     * ``typing.Set[T]``.
     * ``typing.Final[T]`` and ``typing.Annotated[T]``.
     * ``typing.Union[T1, T2]``.
     * Various nested combinations of the above: ``Optional[Literal[T]]``\ ,
       ``Final[Optional[Sequence[T]]]``\ , etc.

   * Hierarchical structures via nested dataclasses, TypedDict, NamedTuple,
     classes.

     * Simple nesting.
     * Unions over nested structures (subparsers).
     * Optional unions over nested structures (optional subparsers).

   * Generics (including nested generics).

   :param f: Callable.
   :param prog: The name of the program printed in helptext. Mirrors argument from
                ``argparse.ArgumentParser()``.
   :param description: Description text for the parser, displayed when the --help flag is
                       passed in. If not specified, ``f``\ 's docstring is used. Mirrors argument from
                       ``argparse.ArgumentParser()``.
   :param args: If set, parse arguments from a sequence of strings instead of the
                commandline. Mirrors argument from ``argparse.ArgumentParser.parse_args()``.
   :param default_instance: An instance of ``T`` to use for default values; only supported
                            if ``T`` is a dataclass, TypedDict, or NamedTuple. Helpful for merging CLI
                            arguments with values loaded from elsewhere. (for example, a config object
                            loaded from a yaml file)
   :param avoid_subparsers: Avoid creating a subparser when defaults are provided for
                            unions over nested types. Generates cleaner but less expressive CLIs.

   :returns: The output of ``f(...)``.

.. py:function:: generate_parser(f: Callable[Ellipsis, T], *, prog: Optional[str] = None, description: Optional[str] = None, args: Optional[Sequence[str]] = None, default_instance: Optional[T] = None, avoid_subparsers: bool = False) -> argparse.ArgumentParser

   
   Returns the argparse parser that would be used under-the-hood if ``dcargs.cli()``
   was called with the same arguments.

   This can be useful for libraries like argcomplete, pyzshcomplete, or shtab, which
   enable autocompletion for argparse parsers.

.. py:data:: MISSING
   :annotation: :Any

   
   Sentinel value to mark fields as missing. Can be used to mark fields passed in as a
   ``default_instance`` for ``dcargs.cli()`` as required.

.. py:exception:: UnsupportedTypeAnnotationError

   Bases: :py:obj:`Exception`

   
   Exception raised when an unsupported type annotation is detected.

