:py:mod:`dcargs.extras`
=======================

.. py:module:: dcargs.extras

.. autoapi-nested-parse::

   
   The :mod:`dcargs.extras` submodule contains helpers that complement :func:`dcargs.cli()`.

   Compared to the core interface, APIs here are more likely to be changed or deprecated.


Package Contents
----------------

.. py:function:: set_accent_color(accent_color: Optional[str]) -> None

   
   Set an accent color to use in help messages. Takes any color supported by ``rich``\ ,
   see ``python -m rich.color``. Experimental.

.. py:function:: get_parser(f: Union[Type[OutT], Callable[Ellipsis, OutT]], *, prog: Optional[str] = None, description: Optional[str] = None, default: Optional[OutT] = None) -> argparse.ArgumentParser

   
   Get the ``argparse.ArgumentParser`` object generated under-the-hood by
   ``dcargs.cli()``. Useful for tools like ``sphinx-argparse``\ , ``argcomplete``\ , etc.

   For tab completion, we recommend using ``dcargs.cli()``\ 's built-in ``--dcargs-print-completion``
   flag.

.. py:function:: subcommand_type_from_defaults(defaults: Mapping[str, T], descriptions: Mapping[str, str] = {}, *, prefix_names: bool = True) -> Type[T]

   
   Construct a Union type for defining subcommands that choose between defaults.

   This can most commonly be used to create a "base configuration" pattern:
       https://brentyi.github.io/dcargs/examples/10_base_configs/

   For example, when ``defaults`` is set to:

   .. code-block:: python

      {
          "small": Config(...),
          "big": Config(...),
      }

   We return:

   .. code-block:: python

      Union[
          Annotated[
              Config,
              dcargs.conf.subcommand("small", default=Config(...))
          ],
          Annotated[
              Config,
              dcargs.conf.subcommand("big", default=Config(...))
          ]
      ]

   The resulting type can be used directly in dcargs.cli:

   .. code-block:: python

      config = dcargs.cli(subcommand_type_from_defaults(default_from_name))
      reveal_type(config)  # Should be correct!

   Or to generate annotations for classes and functions:

   .. code-block:: python

      SelectableConfig = subcommand_type_from_defaults(default_from_name)

      def train(
          config: SelectableConfig,
          checkpoint_path: Optional[pathlib.Path] = None,
      ) -> None:
          ...

      dcargs.cli(train)

   Note that Pyright understands the latter case, but mypy does not. If mypy support is
   necessary we can work around this with an ``if TYPE_CHECKING`` guard:

   .. code-block:: python

      if TYPE_CHECKING:
          SelectableConfig = ExperimentConfig
      else:
          SelectableConfig = subcommand_type_from_defaults(base_mapping)

.. py:function:: literal_type_from_choices(choices: Iterable[T]) -> Type[T]

   
   Generate a typing.Literal[] type that constrains values to a set of choices.

   Using Literal[...] directly should generally be preferred, but this helper can be
   used in the rare case that choices are generated dynamically. (for example, the keys
   of a dictionary)

   Using the returned type as an annotation currently breaks for mypy, but is
   understood by Pyright.

.. py:function:: from_yaml(cls: Type[DataclassType], stream: Union[str, IO[str], bytes, IO[bytes]]) -> DataclassType

   
   Re-construct a dataclass instance from a yaml-compatible string, which should be
   generated from ``dcargs.extras.to_yaml()``.

   As a secondary feature aimed at enabling the use of :func:`dcargs.cli` for general
   configuration use cases, we also introduce functions for human-readable dataclass
   serialization: :func:`dcargs.conf.from_yaml` and :func:`dcargs.conf.to_yaml` attempt
   to strike a balance between flexibility and robustness — in contrast to naively
   dumping or loading dataclass instances (via pickle, PyYAML, etc), explicit type
   references enable custom tags that are robust against code reorganization and
   refactor, while a PyYAML backend enables serialization of arbitrary Python objects.

   .. warning::
       Serialization functionality is stable but deprecated. It may be removed in a
       future version of :code:`dcargs`.

   :param cls: Type to reconstruct.
   :param stream: YAML to read from.

   :returns: Instantiated dataclass.

.. py:function:: to_yaml(instance: Any) -> str

   
   Serialize a dataclass; returns a yaml-compatible string that can be deserialized
   via ``dcargs.extras.from_yaml()``.

   As a secondary feature aimed at enabling the use of :func:`dcargs.cli` for general
   configuration use cases, we also introduce functions for human-readable dataclass
   serialization: :func:`dcargs.conf.from_yaml` and :func:`dcargs.conf.to_yaml` attempt
   to strike a balance between flexibility and robustness — in contrast to naively
   dumping or loading dataclass instances (via pickle, PyYAML, etc), explicit type
   references enable custom tags that are robust against code reorganization and
   refactor, while a PyYAML backend enables serialization of arbitrary Python objects.

   .. warning::
       Serialization functionality is stable but deprecated. It may be removed in a
       future version of :code:`dcargs`.

   :param instance: Dataclass instance to serialize.

   :returns: YAML string.

