:orphan:

:py:mod:`dcargs._resolver`
==========================

.. py:module:: dcargs._resolver

.. autoapi-nested-parse::

   
   Utilities for resolving types and forward references.


Module Contents
---------------

.. py:data:: TypeOrCallable
   

   

.. py:function:: unwrap_origin_strip_extras(typ: TypeOrCallable) -> TypeOrCallable

   
   Returns the origin, ignoring typing.Annotated, of typ if it exists. Otherwise, returns typ.

.. py:function:: is_dataclass(cls: Union[Type, Callable]) -> bool

   
   Same as ``dataclasses.is_dataclass``\ , but also handles generic aliases.

.. py:function:: resolve_generic_types(cls: TypeOrCallable) -> Tuple[TypeOrCallable, Dict[TypeVar, Type]]

   
   If the input is a class: no-op. If it's a generic alias: returns the origin
   class, and a mapping from typevars to concrete types.

.. py:function:: resolved_fields(cls: Type) -> List[dataclasses.Field]

   
   Similar to dataclasses.fields, but resolves forward references.

.. py:function:: is_namedtuple(cls: Type) -> bool


.. py:function:: type_from_typevar_constraints(typ: Union[Type, TypeVar]) -> Union[Type, TypeVar]

   
   Try to concretize a type from a TypeVar's bounds or constraints. Identity if
   unsuccessful.

.. py:data:: TypeT
   

   

.. py:function:: narrow_type(typ: TypeT, default_instance: Any) -> TypeT

   
   Type narrowing: if we annotate as Animal but specify a default instance of Cat, we
   should parse as Cat.

   Note that Union types are intentionally excluded here.

.. py:data:: MetadataType
   

   

.. py:function:: unwrap_annotated(typ: TypeOrCallable, search_type: Optional[Type[MetadataType]] = None) -> Tuple[TypeOrCallable, Tuple[MetadataType, Ellipsis]]

   
   Helper for parsing typing.Annotated types.

   Examples:


   * int, int => (int, ())
   * Annotated[int, 1], int => (int, 1)
   * Annotated[int, "1"], int => (int, None)

.. py:function:: apply_type_from_typevar(typ: TypeOrCallable, type_from_typevar: Dict[TypeVar, Type]) -> TypeOrCallable


